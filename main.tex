% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}
\hyphenation{Monad Applicative Functor}
    \tikzstyle{every node}=[shape=rectangle, color=black, rounded corners,%
    text=black, anchor=west]
    \tikzstyle{selected}=[shape=rectangle, rounded corners,%
    top color=gray,%
    bottom color=gray, text=white]
    \tikzstyle{optional}=[dashed,fill=gray!50]

\begin{document}

\Intro

Функциональные языки имеют множество неоспоримых достоинств, таких как: повышенная надёжность кода, удобство организации модульного тестирования, возможности оптимизации при компиляции, возможности автоматического распараллеливания вычислений. Поэтому в последнее время языки функционального программирования стремительно развиваются. Одним из наиболее популярных функциональных языков является \textit{Haskell}~---  язык программирования общего назначения, имеющий полную, сильную, статическую систему типов.

\subsection*{Цель работы}
Одной из идиом языка программирования \textit{Haskell} являются так называемые \textit{классы типов}. Классы типов в некотором смысле схожи с интерфейсами  объектно-ориентированных языках. В частности, классы типов также реализуют наследование, при котором наследник уточняет функционал предка. Однако класс \textit{Monad}, по смыслу наследовавший класс \textit{Applicative}, синтаксически оставался самостоятельным классом.

В марте 2015 года вышла новая версия компилятора: GHC 7.10. В этой версии было реализовано предложение, известное как \textit{The Applicative Monad Proposal}.[link to AMP] Суть этого предложения заключается в том, чтобы сделать класс \textit{Monad} подклассом класса \textit{Applicative}, в результате чего получается следующая цепочка: \textit{Functor --- Applicative --- Monad}. Теперь, описывая экземпляры класса \textit{Monad}, необходимо также создавать экземпляры классов \textit{Functor} и \textit{Applicative}. В версия GHC, младших, чем 7.10 \textit{Monad} был самостоятельным классом, поэтому для получения работоспособного кода в этих экземплярах не было необходимости. Таким образом, в результате этих изменений, часть программ, компилирующихся версиями GHC, младше, чем 7.10, перестали компилироваться версией GHC 7.10.

\subsection*{Постановка задачи}
Дописывать необходимые экземпляры вручную непрактично, особенно в случае больших объёмов кода. Поэтому требуется создать программное средство, которое восстановит компилируемость этих программ.

Было принято решение создать утилиту с помощью средств самого языка Haskell, а именно при помощи библиотеки \textit{GHC API} --- программного интерфейса компилятора GHC. Утилита должна работать следующим образом:
\begin{enumerate}[1)]
\item получать синтаксическое дерево программы;
\item отфильтровывать узлы, соответствующие экземплярам класса \textit{Monad};
\item изменять нужным образом экземпляр класса \textit{Monad} и добавлять, если требуется, экземпляры классов \textit{Applicative} и \textit{Functor}.
\item формировать новый файл с текстом программы с помощью функций структурной печати (\textit{pretty-printing}).
\end{enumerate}


% Если typeOfWork в SETUP.tex задан как 2 или 3, то начинать
% надо не с section (раздел), а с главы (chapter)
\section{Предварительные сведения}
\label{sec:prelim}

\subsection{GHC: создание, развитие, архитектура}
\textbf{Glasgow Haskell Compiler (GHC)}~--- один из наиболее развитых на сегодняшний день компилятор языка Haskell. Является кроссплатформенным компилятором с открытым исходным кодом. На данный момент история развития GHC насчитывает более двадцати лет. С моента своего создания компилятор постоянно совершенствуется. Сначала GHC был частью академического исследовательского проекта, который спонсировался правительством Великобритании в начале 1990-х годов. Создатели GHC преследовали несколько целей:
\begin{itemize}
\item создать широкодоступный, надёжный компилятор языка \textit{Haskell}, генерирующий высокопроизводительный код;
\item обеспечить модульную основу, которую другие исследователи могли бы развивать и расширять;
\item изучать работу программ, чтобы улучшить дальнейшую разработку компиляторов.
\end{itemize}

GHC можно разделить на три сущности:
\begin{description}
\item[Собственно компилятор.] По существу представляет собой программу на языке \textit{Haskell}, которая преобразует исходный код в исполняемый машинный код.
\item[Загрузочные библиотеки (Boot Libraries).] GHC создан методом \textit{раскрутки компилятора} (англ. \textit{bootstrapping})[link to wiki], т.~е. GHC написан на самом языке Haskell. GHC комплектуется набором библиотек, называемых \textit{загрузочными}, поскольку на них базируется сам компилятор. Наличие этих библиотек позволяет GHC осуществить раскрутку.
\item[Среда выполнения (The Runtime System, RTS).] Написана на языках \textit{C} и \textit{C$--$}. Обрабатывает все задачи, связанные с запуском скомпилированного кода на языке \textit{Haskell}.
\end{description}
На самом деле, такое разделение в точности соответствует трём подкаталогам дерева исходных кодов GHC: \textit{compiler}, \textit{libraries} и \textit{rts} соответственно.

Остановимся подробнее на самом \textbf{компиляторе}.

Компилятор, в свою очередь, также можно разделить на несколько частей.
\begin{description}
\item[Диспетчер компиляции (compilation manager).] Отвечает за компиляцию исходного кода, состоящего из нескольких и более модулей. Его задача заключается в том,чтобы определять, в каком порядке следует компилировать модули, а также какие модули перекомпилировать не нужно, если с момента последней компиляции в их зависимости не были внесены изменения.
\item[Компилятор языка Haskell (Haskell compiler, Hsc).] Управляет компиляцией одного файла исходного кода. Большинство действий над кодом совершается именно здесь.
\item[Конвейер (pipeline).] Отвечает за коллаборацию \textit{Hsc} с необходимыми внешними программами. Например, иногда файл исходного кода сначала должен пройти предварительную обработку через препроцессор $C$ прежде чем быть переданным Hsc. Выходной же файл Hsc~--- это обычно файл на языке ассемблера, который должен затем быть переданным ассемблеру для получения объектного файла.
\end{description}

%Внешний интерфейс (front end) GHC (включающий лексический анализатор (lexer), синтаксический анализатор (parser) и верификатор типов (typechecker)) устроен таким образом, чтобы (<слишком сложно, не могу перевести, да и надо ли об этом говорить... Но если не об этом, то о чём тогда?!>)


\subsection{GHC 7.8~--- GHC 7.10}
Как уже было сказано, GHC~--- один из наиболее развитых компиляторов языка \textit{Haskell} на сегодняшний день. Обновления для GHC выходят регулярно. К сожалению, иногда выход обновлений приводит к определённым проблемам, как, например, потеря обратной совместимости. В данной работе решается проблема обратной совместимости версий GHC 7.10 и версий, младше 7.10.

Так, одним из изменений, появившихся в GHC 7.10, отличающих его от GHC 7.8 стала реализация предложения, известного как \textit{Applicative Monad Proposal} (\textit{AMP}). Суть его состоит в том, чтобы сделать класс \textit{Applicative} надклассом класса \textit{Monad} (и в дополнение к классу \textit{MonadPlus}). [link to AMP] 

Так, в версиях GHC младших, чем 7.10 \textit{Monad} был самостоятельным классом. Однако по смыслу он уточнял функционал класса \textit{Applicative}. Так, идентичными являются функции:
\begin{itemize}
\item \textbf{pure} из \textit{Applicative} и \textbf{return} из \textit{Monad}: обе принимают <<чистое>> значение и помещают его в минимальный контекст по умолчанию;
\item \textbf{$>*$} из \textit{Applicative} \textbf{$>>$} из \textit{Monad} работают идентично.
\end{itemize}
Однако \textit{Monad} <<уточнял>> функционал \textit{Applicative} с помощью функции \textbf{$>>=$} (\textit{связывание, bind}). Таким образом, было принято решение сделать класс \textit{Monad} подклассом класса \textit{Applicative} также и синтаксически.

О других изменениях, произошедших в GHC 7.10 по сравнению с GHC 7.8 см \textit{Release notes for version 7.10.1}[link]

%\begin{figure}[h]
%\begin{lstlisting}
%\end{lstlisting}
%\caption{Реализация класа Monad в GHC 7.8 (библиотека base версии 4.7.0.2).}\label{oldmonad}
%\end{figure}

\subsection{GHC API~--- программный интерфейс компилятора}
Функционал GHC может быть использован не только для компиляции программ на языке Haskell. Важным примером использования может послужить анализ и, возможно, преобразование кода на языке Haskell. Другим примером является динамическая загрузка кода, как в GHCi.[link to GHC as a Library] Для этих целей функционал GHC доступен через библиотеку GHC API.

Рассмотрим основные модули этой библиотеки, функционал которых применялся в данной работе.
\begin{description}
\item[Parser.] Данный модуль предоставляет функции, которые проводят лексический анализ (\textit{parsing}) кода на языке \textit{Haskell}. Данные функции принимают файл или строку исходного кода и дают на выходе абстрактное синтаксическое дерево (\textit{abstract syntax tree}, \textit{AST}), либо сообщение об ошибке.
\item[HsSyn.] Содержит описание структуры верхнего уровня для модуля (\textit{HsModule}). Объект такого типа данных можно получить, если к файлу с исходным кодом применить функцию \textbf{parseModule} из модуля \textit{Parser}.
\item[HsDecls.] Здесь определён абстрактный синтаксис для глобальных объявлений, таких как объявление типа, класса, экземпляра и т.~д.
\item[HsTypes.] В данном модуле описан абстрактный синтаксис для типов, определённых пользователем.
\item[Outputable.] В данном модуле определены классы и функции структурной печати (\textit{pretty-printing}). В частности, здесь определён класс \textbf{Outputable}: если тип данных имеет экземпляр этого класса, значит, к нему можно применять функции структурной печати. Эти функции возвращают объект типа данных \textbf{SDoc}, который в свою очередь легко преобразовать к строке.
\item[DynFlags.] Параметры компиляции. Большинство флагов являются динамическими. Это означает, что они могут изменяться от одного процесса компиляции к другому.
\item[SrcLoc.] Данный модуль содержит типы, относящиеся к положению различных элементов в файле исходного кода и позволяющие присваивать метки этом положениям. 
\end{description}

Более подробно см. документацию по GHC API [link to GHC API]

\newpage
\section{Решение}
\subsection{Получить синтаксическое дерево}
Для начала необходимо провести синтаксический анализ (\textit{parsing}) файла с исходным кодом и получить дерево разбора (синтаксическое дерево).
Для этого опишем функцию, котрая принимает имя файла с исходным кодом и возвращает объект типа данных \textit{HsModule} (структура верхнего уровня для модуля). Схематично \textit{HsModule} представлен на рис.~\ref{hsmod}. 
\begin{figure}[h]
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node {HsModule}
    child { node {hsmodName}}
    child { node {hsmodExports}}		
    child { node {hsmodImports}}
    child { node {hsmodDecls}
      child { node {InstD}}
      child { node {TyClD}}
      child { node {DerivD}}      
      child { node {$\ldots$}}
    }
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child { node {hsmodDeprecMessage}}
    child { node {hsmodHaddockModHeader}};
\end{tikzpicture}
\caption{Структура верхнего уровня HsModule}\label{hsmod}
\end{figure}
\newpage
\subsection{Отфильтровать экземпляры класса Monad}
Далее получим экземпляры класса \textit{Monad}. Необходимо отфильтровать только те экземпляры, для которых нет соответствующих им экземпляров класса \textit{Applicative}  и/или \textit{Functor}.
\begin{enumerate}
\item Сначала выберем все объявления. Для этого оставим только ветвь \textit{hsmodDecls} (см. рис.~\ref{filter}). Каждое объявление описывается типом данных \textit{HsDecl}. \textit{HsDecl} в свою очередь имеет несколько конструкторов:
    \begin{itemize}
        \item \lstinline{TyClD (TyClDecl id)} для классов и типов, определённых пользователем;
        \item \lstinline{InstD (InstDecl id)} для объявлений экземпляров;
        \item \lstinline{ValD (HsBind id)} для функций, констант и т.п.;
        \item и др.
    \end{itemize}
\item С помощью сопоставления с образцом (\textit{pattern-matching}) выберем только объявления экземпляров. Они имеют тип данных \textit{InstDecl}. У типа данных \textit{InstDecl} также имеется несколько конструкторов:
    \begin{itemize}
        \item \begin{lstlisting}
  ClsInstD {cid_inst :: ClsInstDecl name}
              \end{lstlisting}
        \item 
        \begin{lstlisting}
  DataFamInstD {dfid_inst :: DataFamInstDecl name} 
        \end{lstlisting}
        \item \begin{lstlisting}
  TyFamInstD {tfid_inst :: TyFamInstDecl name}
              \end{lstlisting}
    \end{itemize}
\item Снова применяя сопоставление с образцом, выберем только те объекты типа данных \textit{InstDecl}, которые были созданы с помощью конструктора \textit{ClsInstDecl}~--- это и есть экземпляры классов типов.
\item Теперь необходимо выбрать только экземпляры класса \textit{Monad}. Обратимся к конструктору типа данных \textit{ClsInstDecl}. Первое поле этого конструктора \lstinline{cid_poly_ty} определяет, экземпляр какого класса описан. Опишем предикат, который определяет, что это действительно экземпляр класса \textit{Monad}. Наконец, с помощью функции \textbf{filter} из модуля \textit{Data.List} отфильтруем экземпляры из списка, полученного в пункте 3, удовлетворяющие предикату.
\item Применяя вышеописанные функции, получим также экземпляры классов \textit{Functor} и \textit{Applicative}.
\item Наконец, отфильтруем только те экземпляры класса \textit{Monad}, для которых нет соответствующих им экземпляров классов \textit{Applicative} и/или \textit{Functor} (то есть те, для которых нет экземпляров классов \textit{Applicative} и \textit{Functor}, созданных для тех же самых типов данных).
\end{enumerate}

\begin{figure}[h]
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node {hsModule}
    child { node {hsmodName}}		
    child { node {hsmodExports}}
    child { node {hsmodImports }}
    child { node [selected] {hsmodDecls}
      child { node [selected] {InstD}
        child { node [selected] {ClsInstD}}
        child { node {DataFamInstD}}
        child { node {TyFamInstD}}  
      }     
      child [missing] {}				
      child [missing] {}				
      child [missing] {}				    
      child { node [selected] {$\ldots$}}
    }
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child { node {hsmodDeprecMessage}}
    child { node {hsmodHaddockModHeader}};
      \end{tikzpicture}
\caption{Экземпляры классов в синтаксическом дереве}\label{filter}
\end{figure}
\newpage
\subsection{Генерация экземпляров классов Applicative и Functor}
\subsubsection{Подключение модулей}
Сначала убедимся, что подключены модули:
    \begin{itemize}
        \item \lstinline{Data.Functor}, содержащий реализацию класса \textit{Functor};
        \item \lstinline{Control.Applicative}, содержащий реализацию класса \textit{Applicative}.
    \end{itemize}

\begin{enumerate}
\item Выберем все подключения (\textit{imports}). Для этого возьмём ветвь \textit{hsmodImports}. Каждое подключение описывается типом данных \textit{ImportDecl} (см. рис.~\ref{import}).
\item Рассмотрим конструктор типа данных \textit{ImportDecl}. Нас интересует поле \textit{ideclName}~--- это имя импортируемого модуля. Преобразуем имена импортируемых модулей к строкам и проверим, есть ли среди них значения \textit{<<Data.Functor>>} либо \textit{<<Control.Applicative>>}.
\item Если интересующие нас имена модулей не найдены, то их импорты необходимо добавить~\autocite{wikiGHC}.
\end{enumerate}

\begin{figure}[h]
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node {ImportDecl}
    child { node {ideclName}}
    child { node {ideclPkgQual}}
    child { node {ideclQualified}}
    child { node {ideclImplicit}}
    child { node {$\ldots$}};
      \end{tikzpicture}
\caption{Структура данных для import'а}\label{import}
\end{figure}

\subsection{Формирование выходного файла}
\subsection{Другие способы решения}


% Печать списка литературы (библиографии)
\printbibliography[%{}
    heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
