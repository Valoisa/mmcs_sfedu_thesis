% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (section) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}
\hyphenation{Monad Applicative Functor Control Data}
    \tikzstyle{every node}=[shape=rectangle, color=black, rounded corners,%
    text=black, anchor=west]
    \tikzstyle{selected}=[shape=rectangle, rounded corners,%
    top color=gray,%
    bottom color=gray, text=white]
    \tikzstyle{optional}=[dashed,fill=gray!50]

\begin{document}

\Intro

Функциональные языки имеют множество неоспоримых достоинств, таких как: повышенная надёжность кода, удобство организации модульного тестирования, возможности оптимизации при компиляции, возможности автоматического распараллеливания вычислений. Поэтому в последнее время языки функционального программирования стремительно развиваются. Одним из наиболее популярных функциональных языков является \textit{Haskell}~---  язык программирования общего назначения, имеющий полную, сильную, статическую систему типов.

\section*{Цель работы}
Одной из идиом языка программирования \textit{Haskell} являются так называемые \textit{классы типов}. Классы типов в некотором смысле схожи с интерфейсами  объектно-ориентированных языках. В частности, классы типов также реализуют наследование, при котором наследник уточняет функционал предка. Однако класс \textit{Monad}, по смыслу наследовавший класс \textit{Applicative}, синтаксически оставался самостоятельным классом.

В марте 2015 года вышла новая версия компилятора: GHC 7.10. В этой версии было реализовано предложение, известное как \textit{The Applicative Monad Proposal}~\autocite{AMP}. Суть этого предложения заключается в том, чтобы сделать класс \textit{Monad} подклассом класса \textit{Applicative}, в результате чего получается следующая цепочка наследования: \textit{Functor~--- Applicative~--- Monad}. Теперь, описывая экземпляры класса \textit{Monad}, необходимо также создавать экземпляры классов \textit{Functor} и \textit{Applicative}. В версия GHC, младших, чем 7.10 \textit{Monad} был самостоятельным классом, поэтому для получения работоспособного кода в этих экземплярах не было необходимости. Таким образом, в результате этих изменений, часть программ, компилирующихся версиями GHC, младше, чем 7.10, перестали компилироваться версией GHC 7.10.

\section*{Постановка задачи}
Дописывать необходимые экземпляры вручную непрактично, особенно в случае больших объёмов кода. Поэтому требуется создать программное средство, которое восстановит компилируемость этих программ.

Было принято решение создать утилиту с помощью средств самого языка Haskell, а именно при помощи библиотеки \textit{GHC API} --- программного интерфейса компилятора GHC. Утилита должна работать следующим образом:
\begin{enumerate}[1)]
\item получать синтаксическое дерево программы;
\item отфильтровывать узлы, соответствующие экземплярам класса \textit{Monad};
\item изменять нужным образом экземпляр класса \textit{Monad} и добавлять, если требуется, экземпляры классов \textit{Applicative} и \textit{Functor}.
\item формировать новый файл с текстом программы с помощью функций структурной печати (\textit{pretty-printing}).
\end{enumerate}


% Если typeOfWork в SETUP.tex задан как 2 или 3, то начинать
% надо не с section (раздел), а с главы (chapter)
\newpage
\chapter{Предварительные сведения}
\label{sec:prelim}

\section{GHC: создание, развитие, архитектура}
\textbf{Glasgow Haskell Compiler (GHC)}~--- один из наиболее развитых на сегодняшний день компилятор языка Haskell. Является кроссплатформенным компилятором с открытым исходным кодом. С момента своего создания компилятор постоянно совершенствуется. Сначала GHC был частью академического исследовательского проекта, который спонсировался правительством Великобритании в начале 1990-х годов. Создатели GHC преследовали несколько целей:
\begin{enumerate}[1)]
\item создать широкодоступный, надёжный компилятор языка \textit{Haskell}, генерирующий высокопроизводительный код;
\item обеспечить модульную основу, которую другие исследователи могли бы развивать и расширять;
\item изучать работу программ, чтобы улучшить дальнейшую разработку компиляторов.
\end{enumerate}

GHC можно разделить на три сущности:
\begin{description}
\item[Собственно компилятор.] По существу представляет собой программу на языке \textit{Haskell}, которая преобразует исходный код в исполняемый машинный код.
\item[Загрузочные библиотеки (Boot Libraries).] GHC создан методом \textit{раскрутки компилятора} (англ. \textit{bootstrapping})~\autocite{wikiGHC}, т.~е. GHC написан на самом языке Haskell. GHC комплектуется набором библиотек, называемых \textit{загрузочными}, поскольку на них базируется сам компилятор. Наличие этих библиотек позволяет GHC осуществить раскрутку.
\item[Среда выполнения (The Runtime System, RTS).] Написана на языках \textit{C} и \textit{C$--$}. Обрабатывает все задачи, связанные с запуском скомпилированного кода на языке \textit{Haskell}.
\end{description}
На самом деле, такое разделение в точности соответствует трём подкаталогам дерева исходных кодов GHC: \textit{compiler}, \textit{libraries} и \textit{rts} соответственно.

Остановимся подробнее на самом компиляторе. Компилятор, в свою очередь, также можно разделить на несколько частей.
\begin{description}
\item[Диспетчер компиляции (compilation manager).] Отвечает за компиляцию исходного кода, состоящего из нескольких и более модулей. Его задача заключается в том,чтобы определять, в каком порядке следует компилировать модули, а также какие модули перекомпилировать не нужно, если с момента последней компиляции в их зависимости не были внесены изменения.
\item[Компилятор языка Haskell (Haskell compiler, Hsc).] Управляет компиляцией одного файла исходного кода. Большинство действий над кодом совершается именно здесь.
\item[Конвейер (pipeline).] Отвечает за коллаборацию \textit{Hsc} с необходимыми внешними программами. Например, иногда файл исходного кода сначала должен пройти предварительную обработку через препроцессор $C$ прежде чем быть переданным Hsc. Выходной же файл Hsc~--- это обычно файл на языке ассемблера, который должен затем быть переданным ассемблеру для получения объектного файла.
\end{description}

%Внешний интерфейс (front end) GHC (включающий лексический анализатор (lexer), синтаксический анализатор (parser) и верификатор типов (typechecker)) устроен таким образом, чтобы (<слишком сложно, не могу перевести, да и надо ли об этом говорить... Но если не об этом, то о чём тогда?!>)


\section{GHC~7.8~--- GHC~7.10}\label{710}
Как уже было сказано, GHC~--- один из наиболее развитых компиляторов языка \textit{Haskell} на сегодняшний день. Обновления для GHC выходят регулярно. К сожалению, иногда выход обновлений приводит к определённым проблемам, как, например, потеря обратной совместимости. В данной работе решается проблема обратной совместимости версий GHC 7.10 и версий, младше 7.10.

Так, одним из изменений, появившихся в GHC~7.10, отличающих его от GHC~7.8 стала реализация предложения, известного как \textit{Applicative Monad Proposal} (\textit{AMP}). Суть его состоит в том, чтобы сделать класс \textit{Applicative} надклассом класса \textit{Monad} (и в дополнение класса \textit{MonadPlus})~\autocite{AMP}.

Так, в версиях GHC младших, чем 7.10 \textit{Monad} был самостоятельным классом. Однако по смыслу он уточнял функционал класса \textit{Applicative}. Так, идентичными являются функции:
\begin{enumerate}[1)]
\item \lstinline{pure} из \textit{Applicative} и \lstinline{return} из \textit{Monad}: обе принимают <<чистое>> значение и помещают его в минимальный контекст по умолчанию;
\item \textbf{$*>$} из \textit{Applicative} \textbf{$>>$} из \textit{Monad} работают идентично.
\end{enumerate}
Однако \textit{Monad} <<уточнял>> функционал \textit{Applicative} с помощью функции \textbf{$>>=$} (\textit{связывание, bind}). Таким образом, было принято решение сделать класс \textit{Monad} подклассом класса \textit{Applicative} также и синтаксически.

О других изменениях, произошедших в GHC~7.10 по сравнению с GHC~7.8 см \textit{Release notes for version 7.10.1}~\autocite{release}.

%\begin{figure}[h]
%\begin{lstlisting}
%\end{lstlisting}
%\caption{Реализация класа Monad в GHC 7.8 (библиотека base версии 4.7.0.2).}\label{oldmonad}
%\end{figure}

\section{GHC API~--- программный интерфейс компилятора}\label{ghcapi}
Функционал GHC может быть использован не только для компиляции программ на языке Haskell. Важным примером использования может послужить анализ и, возможно, преобразование кода на языке Haskell. Другим примером является динамическая загрузка кода, как в GHCi~\autocite{GHClib}. Для этих целей функционал GHC доступен через библиотеку GHC~API.

Рассмотрим основные модули этой библиотеки, функционал которых применялся в данной работе.
\begin{description}
\item[Parser.] Данный модуль предоставляет функции, которые проводят лексический анализ (\textit{parsing}) кода на языке \textit{Haskell}. Данные функции принимают файл или строку исходного кода и дают на выходе абстрактное синтаксическое дерево (\textit{abstract syntax tree}, \textit{AST}), либо сообщение об ошибке.
\item[HsSyn.] Содержит описание структуры верхнего уровня для модуля (\textit{HsModule}). Объект такого типа данных можно получить, если к файлу с исходным кодом применить функцию \textbf{parseModule} из модуля \textit{Parser}.
\item[HsDecls.] Здесь определён абстрактный синтаксис для глобальных объявлений, таких как объявление типа, класса, экземпляра и т.~д.
\item[HsTypes.] В данном модуле описан абстрактный синтаксис для типов, определённых пользователем.
\item[Outputable.] В данном модуле определены классы и функции структурной печати (\textit{pretty-printing}). В частности, здесь определён класс \textbf{Outputable}: если тип данных имеет экземпляр этого класса, значит, к нему можно применять функции структурной печати. Эти функции возвращают объект типа данных \textbf{SDoc}, который в свою очередь легко преобразовать к строке.
\item[DynFlags.] Параметры компиляции. Большинство флагов являются динамическими. Это означает, что они могут изменяться от одного процесса компиляции к другому.
\item[SrcLoc.] Данный модуль содержит типы, относящиеся к положению различных элементов в файле исходного кода и позволяющие присваивать метки этом положениям. 
\end{description}

Более подробно см. документацию по GHC~API~\autocite{apidoc}.

\section{Экземпляр-сирота (orphan instance)}
При решении поставленной задачи необходимо будет убедиться, что у экземпляра класса \textit{Monad} отсутствуют уже описанные соответствующие ему экземпляры классов \textit{Applicative} и \textit{Functor}. Однако в многомодульных проектах может возникнуть ситуация, при которой экземпляры разных классов оказались в разных модулях. Если экземпляр класса типов \textit{C} для типа \textit{T} описан в модуле, в котором не описан ни класс \textit{C}, ни класс \textit{T}, то он называется \textit{экземпляр-сирота} (\textit{orphan instance})~\autocite{orphinst}. 

Проверим, в каком случае наличие такого экземпляра возможно в условиях поставленной задачи. Для этого создадим два простейших модуля: \textit{Moduleone.hs} (см. листинг~\ref{one}) и \textit{Moduletwo.hs} (см. листинг~\ref{two}) в первом (\textit{Moduleone.hs}) из них опишем свой тип данных \textit{MyData} и экземпляр класса \textit{Monad} для него. В другом (\textit{Moduletwo.hs}) создадим экземпляры классов \textit{Functor} и \textit{Applicative} для \textit{MyData} и подключим в нём \textit{Moduleone} с описанием \textit{MyData}.
\begin{ListingEnv}[b]
\begin{lstlisting}
module Moduleone where

import Control.Monad

data MyData a = MyData a
instance Monad MyData
\end{lstlisting}
\caption{Реализация модуля Moduleone.hs}\label{one}
\end{ListingEnv}

\begin{ListingEnv}[h]
\begin{lstlisting}
module Moduletwo where

import Control.Applicative
import Data.Functor
import Moduleone

instance Functor MyData
instance Applicative MyData
\end{lstlisting}
\caption{Реализация модуля Moduletwo.hs}\label{two}
\end{ListingEnv}

При попытке скомпилировать \textit{Moduletwo.hs} мы получаем сообщение:
\begin{figure}[H]
\begin{verbatim}
$ ghc Moduletwo.hs
[1 of 2] Compiling Moduleone  
            ( Moduleone.hs, Moduleone.o )

Moduleone.hs:7:10:
    No instance for (Applicative MyData)
      arising from the superclasses of 
      an instance declaration
    In the instance declaration for ‘Monad MyData’
\end{verbatim}
\end{figure}

Это означает, что компиляция \textit{Moduleone.hs} не удалась, поскольку в нём присутствует экземпляр класса \textit{Monad}, но отсутствует требуемый экземпляр класса \textit{Applicative}.

Рассмотрим другой вариант. Теперь в \textit{Moduletwo.hs} опишем тип данных \textit{MyData} и определим для него экземпляры классво \textit{Applicative} и \textit{Functor} (см. листинг~\ref{two2}). В модуле \textit{Moduleone.hs} определим экземпляр класса \textit{Monad} и подключим \textit{Moduletwo.hs} (см. листинг~\ref{one2}). Компиляция в этом случае пройдёт успешно. 

\begin{ListingEnv}[t]
\begin{lstlisting}
module Moduleone where

import Control.Monad
import Moduletwo

instance Monad MyData
\end{lstlisting}
\caption{Реализация модуля Moduleone.hs}\label{one2}
\end{ListingEnv}

\begin{ListingEnv}[b]
\begin{lstlisting}
module Moduletwo where

import Control.Applicative
import Data.Functor

data MyData a = MyData a

instance Functor MyData
instance Applicative MyData
\end{lstlisting}
\caption{Реализация модуля Moduletwo.hs}\label{two2}
\end{ListingEnv}

Таким образом, в условиях поставленной задачи может возникнуть ситуация, когда экземпляр класса \textit{Monad} описан в одном модуле, а экземпляры классов \textit{Applicative} и \textit{Functor} (а также и сам тип данных)~--- в другом. Тем не менее, экземпляров-сирот лучше избегать. Поскольку у экземпляров классов типов нет идентификаторов, их нельзя явно исключить: все экземпляры, описанные в некотором модуле импортируются при подключении этого модуля. Поэтому можно описать несколько разных экземпляров одного и того же класса, которые находятся в разных модулях. Однако если в области видимости имеется несколько экземпляров одного и того же класса для одного и того же типа данных, компилятор не может решить, какой из них использовать. Экземпляры, не являющиеся сиротами, позволяют избегать определения множественных экземпляров.

Итак, при решении задачи мы будем рассматривать случай, когда тип данных и экземпляр класса \textit{Monad} для него описаны в одном модуле, т.~е. когда экземпляров-сирот возникнуть не может.

\newpage
\chapter{Основные алгоритмы}
\section{Синтаксическое дерево}
Для начала необходимо провести синтаксический анализ (\textit{parsing}) файла с исходным кодом и получить дерево разбора (синтаксическое дерево).
Для этого нужно описать функцию, которая принимает имя файла с исходным кодом и возвращает объект типа данных \textit{HsModule} (структура верхнего уровня для модуля). Схематично \textit{HsModule} представлен на рис.~\ref{hsmod}. 
\begin{figure}[h]
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node {HsModule}
    child { node {hsmodName}}
    child { node {hsmodExports}}		
    child { node {hsmodImports}}
    child { node {hsmodDecls}
      child { node {InstD}}
      child { node {TyClD}}
      child { node {DerivD}}      
      child { node {$\ldots$}}
    }
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child { node {hsmodDeprecMessage}}
    child { node {hsmodHaddockModHeader}};
\end{tikzpicture}
\caption{Структура верхнего уровня HsModule}\label{hsmod}
\end{figure}

\section{Алгоритм выбора экземпляров класса Monad}\label{filtermonad}
Далее получим экземпляры класса \textit{Monad}. Необходимо отфильтровать только те экземпляры, для которых нет соответствующих им экземпляров класса \textit{Applicative}  и/или \textit{Functor}.
\begin{enumerate}
\item Выберем все объявления. Для этого оставим только ветвь \textit{hsmodDecls} (см. рис.~\ref{filter}).
\item Выберем только объявления экземпляров (см. замечание~\ref{rem1}). Они имеют тип данных \textit{InstDecl}.
\item Оставим только те объекты типа данных \textit{InstDecl} (см. замечание~\ref{rem2}), которые были созданы с помощью конструктора \textit{ClsInstDecl}~--- это и есть экземпляры классов типов.
\item Необходимо выбрать только экземпляры класса \textit{Monad}. Обратимся к конструктору типа данных \textit{ClsInstDecl} (см. рис.~\ref{instance}). Первое поле этого конструктора \lstinline{cid_poly_ty} как раз содержит информацию о том, экземпляр какого класса описан. 
\item С помощью вышеописанных действий, получим также экземпляры классов \textit{Functor} и \textit{Applicative}.
\item Наконец, отфильтруем только те экземпляры класса \textit{Monad}, для которых нет соответствующих им экземпляров классов \textit{Applicative} и/или \textit{Functor} (то есть те, для которых нет экземпляров классов \textit{Applicative} и \textit{Functor}, созданных для тех же самых типов данных).
\end{enumerate}

\myremark {Каждое объявление описывается типом данных \textit{HsDecl}. \textit{HsDecl} в свою очередь имеет несколько конструкторов:
    \begin{enumerate}[1)]
        \item \lstinline{TyClD (TyClDecl id)} для классов и типов, определённых пользователем;
        \item \lstinline{InstD (InstDecl id)} для объявлений экземпляров;
        \item \lstinline{ValD (HsBind id)} для функций, констант и т.п.;
        \item и др.
    \end{enumerate} }\label{rem1}

\myremark{У типа данных \textit{InstDecl} также имеется несколько конструкторов:
    \begin{enumerate}[1)]
        \item \lstinline!ClsInstD {cid_inst :: ClsInstDecl name}!
        \item 
        \lstinline!DataFamInstD {dfid_inst :: DataFamInstDecl name}! 
        
        \item \lstinline!TyFamInstD {tfid_inst :: TyFamInstDecl name}!
    \end{enumerate}}\label{rem2}

\begin{figure}[h]
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node {hsModule}
    child { node {hsmodName}}		
    child { node {hsmodExports}}
    child { node {hsmodImports }}
    child { node [selected] {hsmodDecls}
      child { node [selected] {InstD}
        child { node [selected] {ClsInstD}}
        child { node {DataFamInstD}}
        child { node {TyFamInstD}}  
      }     
      child [missing] {}				
      child [missing] {}				
      child [missing] {}				    
      child { node [selected] {$\ldots$}}
    }
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child { node {hsmodDeprecMessage}}
    child { node {hsmodHaddockModHeader}};
      \end{tikzpicture}
\caption{Экземпляры классов в синтаксическом дереве}\label{filter}
\end{figure}

\section{Алгоритм генерации экземпляров классов Applicative и Functor}\label{generation}
\subsection{Подключение модулей}
Сначала убедимся, что подключены стандартные модули, содержащие реализацию:
    \begin{enumerate}[1)]
        \item класса Functor;
        \item класса Applicative.
    \end{enumerate}

\begin{enumerate}
\item Выберем все подключения (\textit{imports}). Для этого возьмём ветвь \textit{hsmodImports}. Каждое подключение описывается типом данных \textit{ImportDecl} (см. рис.~\ref{import}).
\item Рассмотрим конструктор типа данных \textit{ImportDecl}. Нас интересует поле \textit{ideclName}~--- это имя импортируемого модуля. Проверим, есть ли среди них \textit{Data.Functor} либо \textit{Control.Applicative}.
\item Если интересующие нас имена модулей не найдены, то их импорты необходимо добавить. Сформируем соответствующие объекты типа данных \textit{ImportDecl} и добавим их к уже имеющимся.
\end{enumerate}

\begin{figure}[h]
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node {ImportDecl}
    child { node {ideclName}}
    child { node {ideclPkgQual}}
    child { node {ideclQualified}}
    child { node {ideclImplicit}}
    child { node {$\ldots$}};
      \end{tikzpicture}
\caption{Структура данных для импорта}\label{import}
\end{figure}

\subsection{Непосредственно генерация экземпляров}\label{instgen}
Необходимые экземпляры будем генерировать в соответствии с рекомендациями на \textit{GHC Developer Wiki}~\autocite{migrat}.
\begin{description}
\item[Экземпляр класса Applicative.] Для каждого экземпляра класса \textit{Monad} создадим объект типа \textit{ClsInstDecl} по следующему правилу.
    \begin{enumerate}
        \item Поскольку функции \lstinline{pure} из \textit{Applicative} и \lstinline{return} из \textit{Monad} идентичны (см главу~\ref{710}), то определение функции \lstinline{return} перенесём в определение для \lstinline{pure}. Функцию \lstinline{return} определим в терминах \lstinline{pure}.
        \item Аналогичным образом поступим с функцией \lstinline{(*>)} из класса \textit{Applicative} и \lstinline{(>>)} из \textit{Monad}.
        \item Заменим <<старые>> экземпляры класса \textit{Monad} экземплярами, полученными в предыдущих пунктах. Добавим экземпляры класса \textit{Applicative} к уже имеющимся.
    \end{enumerate}
\item[Экземпляр класса Functor.] Для каждого экземпляра класса \textit{Monad} создадим объект типа \textit{ClsInstDecl} по следующему правилу.
    \begin{enumerate}
        \item Функцию \lstinline{fmap} из класса \lstinline{Functor} определим в терминах \lstinline{liftM} (эта функция описана в стандартном модуле \textit{Control.Monad}).
        \item Добавим очередной экземпляр в ветвь к уже имеющимся.
    \end{enumerate}
\end{description}

Наконец, присоединим описания экземпляров классов к остальным объявлениям (\textit{hsmodDecls}) модуля.

\begin{figure}[h]
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node {ClsInstDecl}
    child { node {cid\_poly\_ty}}
    child { node {cid\_binds}
        child { node {FunBind}
            child { node {fun\_id}}
            child { node {fun\_infix}}
            child { node {fun\_matches}}
            child { node {$\ldots$}}
        }
    }
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child [missing] {}				
    child { node {$\ldots$}};
\end{tikzpicture}
\caption{Структура данных для экземпляра класса}\label{instance}
\end{figure}

\section{Алгоритм формирование выходного файла}
Наконец, необходимо сформировать новое синтаксическое дерево, по которому затем сгенерировать уже работоспособный код.
\begin{enumerate}[1.]
    \item Заменим ветви \textit{hsmodImports} и \textit{hsmodDecls} (рис.~\ref{hsmod}) ветвями, полученными в предыдущих пунктах.
    \item Сгенерируем код из синтаксического дерева при помощи функций структурной печати.
    \item Новый код перезапишем в поданный утилите файл. При этом, если исходный код уже был работоспособным, то выведем соответствующее сообщение и изменять файл не будем.
\end{enumerate}

\section{Другие способы решения}
Для решения данной задачи можно предложить и другие способы.
\begin{enumerate}
\item Установить расширение для компилятора \textit{Deriving Functor}, которое позволяет генерировать экземпляр класса Functor автоматически с помощью ключевого слова \lstinline{deriving}. Однако проблема с экземплярами класса \textit{Applicative} остаётся открытой, кроме того, код программ всё равно придётся править вручную, что непрактично в случае больших объёмов исходного кода. 
\item Написать скрипт, который анализирует текст программы на языке Haskell, используя средства для работы со строками. Данный скрипт должен находить ключевые слова \lstinline{instance Monad}~, а затем дописывать в нужном месте необходимые определения экземпляров других классов. Такой способ также имеет недостатки, поскольку слишком сложно учесть все особенности двумерного синтаксиса языка \textit{Haskell} для того, чтобы на выходе получить работающий код. Кроме этого, сложность представляет проверка наличия уже описанных экземпляров, особенно в случае объёмных проектов, содержащих большое число модулей.
\end{enumerate}

\chapter{Обзор программной реализации}
Программный код разбит на несколько модулей.
\begin{description}
    \item[MyParser.hs:] содержит функции, проводящие синтаксический разбор модулей и строк.
    \item[AppendImport.hs:] в данном модуле описаны функции, решающие задачу импорта дополнительных модулей.
    \item[AppendInstance.hs:] здесь определены функции, формирующие необходимые экземпляры классов типов.
    \item[Manipulation.hs:] содержит некоторые вспомогательные функции.
    \item[FixingMonad.hs:] здесь находится код основной программы (\textit{main}).
    С кодом программы можно ознакомиться в репозитории с исходными кодами~\autocite{github}.
\end{description}
\section{Получение синтаксического дерева}
Для получения синтаксического дерева опишем функцию \lstinline{parseHaskell}(см. листинг~\ref{parser}), принимающую имя файла и возвращающую объект типа данных \textit{HsModule}. Воспользуемся функциями синтаксического разбора из модуля \textit{Parser} (см. главу~\ref{ghcapi}), а именно функцией \textit{parseModule}. Инициализируем состояние парсера (\textit{PState}) при помощи функции \lstinline{mkPState}. Её аргументы:
\begin{enumerate}[1)]
\item \lstinline{dynFl}: динамические флаги (см. главу~\ref{ghcapi});
\item \lstinline{sbuf}: строка, подвергнутая синтаксическому разбору (в данном случае модуль с исходным кодом целиком);
\item \lstinline{srcloc}: расположение в файле (поскольку файл подвергается синтаксическому разбору целиком, то расположение~--- это сам файл).
\end{enumerate}

\begin{ListingEnv}[H]
\begin{lstlisting}
parseHaskell :: FilePath -> IO (Maybe (HsModule RdrName))
parseHaskell file = do
    initStaticOpts
    dynFl <- GHC.runGhc (Just libdir) GHC.getSessionDynFlags
    sbuf <- hGetStringBuffer file
    let srcloc = mkRealSrcLoc (mkFastString file) 1 1
    return $ case unP Parser.parseModule (mkPState dynFl sbuf srcloc) of
        POk _ (L _ mdl) -> Just mdl
        PFailed _ _     -> Nothing
\end{lstlisting}
\caption{Функция parseHaskell}\label{parser}
\end{ListingEnv}
%$
\section{Фильтр экземпляров класса Monad}
Следуя алгоритму, описанному в главе~\ref{filtermonad}, опишем следующие функции.
\begin{enumerate}
\item Функция \lstinline{getHsDecls} (см. листинг~\ref{p1}) выбирает только ветвь с объявлениями.
\item Функция \lstinline{getInstDecls} (см. листинг~\ref{p2}) фильтрует только те объявления, которые являются объявлениями экземпляров. Предикат \lstinline{isInstDecl} проверяет, действительно ли очередное объявление описывает экземпляр. Вспомогательная функция \lstinline{getOneInstDecl} <<достаёт>> отдельно взятое объявление из конструктора.
\item Функция \lstinline{getClsInstDecl} (см листинг~\ref{p3}) отбирает только определения экземпляров классов при помощи предиката \lstinline{isClsInstDecl}, который устанавливает, является ли данный экземпляр экземпляром класса типов.
\item Функция \lstinline{getInstsMonad} (см листинг~\ref{p4}) фильтрует экземпляры класса \textit{Monad} при помощи соответствующего предиката \lstinline{isInstanceMonad}.
\item Получение экземпляров \textit{Functor} и \textit{Applicative} происходит абсолютно аналогично.
\item Функция \lstinline{filterAloneInstMon} (см. листинг~\ref{p6}) принимает список экземпляров класса \textit{Monad} и \textit{Applicative} либо \textit{Functor}. С помощью предиката \lstinline{hasntApprInst} проверяется, есть ли у текущего экземпляра класса \textit{Monad} соответствующий ему экземпляр класса \textit{Applicative} (либо \textit{Functor}).
\end{enumerate}

\begin{ListingEnv}[h]
\begin{lstlisting}
getHsDecls :: IO (Maybe [LHsDecl RdrName]) 
                            -> IO (Maybe [HsDecl RdrName])
getHsDecls md = do
    mp <- md
    case mp of
        Nothing  -> return Nothing
        Just mdl -> return $ Just (map unLoc $ hsmodDecls mdl)
\end{lstlisting}
\caption{Выбор всех объявлений, описанные в модуле}\label{p1}
\end{ListingEnv}

\begin{ListingEnv}[h]
\begin{lstlisting}
isInstDecl :: HsDecl RdrName -> Bool
isInstDecl (InstD _) = True
isInstDecl _         = False

getOneInstDecl :: HsDecl RdrName -> InstDecl RdrName
getOneInstDecl (InstD (a)) = a

getInstDecls :: IO (Maybe [HsDecl RdrName]) 
                  -> IO (Maybe [InstDecl RdrName])
getInstDecls md = do
    mp <- md
    case mp of 
        Nothing  -> return Nothing
        Just mdl -> return $ Just (map getOneInstDecl
                                $ filter isInstDecl mdl)
\end{lstlisting}
\caption{Выбор всех объявлений экземпляров, описанные в модуле}\label{p2}
\end{ListingEnv}

\begin{ListingEnv}[h]
\begin{lstlisting}
isClsInstDecl :: InstDecl RdrName -> Bool
isClsInstDecl (ClsInstD _ ) = True
isClsInstDecl _             = False

getClsInstDecl :: IO (Maybe [InstDecl RdrName]) 
                    -> IO (Maybe [ClsInstDecl RdrName])
getClsInstDecl md = do
    mp <- md
    case mp of
        Nothing  -> return Nothing
        Just mdl -> return $ Just (map cid_inst 
                                    $ filter isClsInstDecl mdl)
\end{lstlisting}
\caption{Выбор всех объявлений экземпляров классов типов, описанные в модуле}\label{p3}
\end{ListingEnv}

\begin{ListingEnv}[h]
\begin{lstlisting}
isInstanceMonad :: ClsInstDecl RdrName -> Bool
isInstanceMonad instD = 
  ((hsTypeToString . whatClassIsInstance) instD) == "Monad"

getInstsMonad :: IO (Maybe [ClsInstDecl RdrName])
                     -> IO (Maybe [ClsInstDecl RdrName])
getInstsMonad md = do
    mp <- md
    case mp of
        Nothing  -> return Nothing
        Just mdl -> return $ Just (filter isInstanceMonad mdl)
\end{lstlisting}
\caption{Выбор всех объявлений экземпляров класса Monad}\label{p4}
\end{ListingEnv}
%$

\begin{ListingEnv}[htb]
\begin{lstlisting}
hasntApprInst :: [ClsInstDecl RdrName] -> ClsInstDecl RdrName
                                       -> Bool
hasntApprInst xs x = not $ elem (showSDocUnsafe 
                         $ ppr $ takeUserData x) 
                  (map (showSDocUnsafe . ppr . takeUserData) xs)

filterAloneInstMon :: Maybe [ClsInstDecl RdrName]
                         -> Maybe [ClsInstDecl RdrName]
                         -> Maybe [ClsInstDecl RdrName]
filterAloneInstMon mpap md = 
    case md of
        Nothing  -> Nothing
        Just mdl -> Just (filter 
                       (hasntApprInst (unMaybeList mpap)) mdl)
\end{lstlisting}
\caption{Выбор всех объявлений экземпляров класса Monad, у которых отсутствуют соответствующие им экземпляры классов Applicative и/или Functor}\label{p6}
\end{ListingEnv}
%$
\section{Генерация экземпляров классов Applicative и
Functor}
\subsection{Импорт модулей}
Если интересующие нас модули оказались не подключены, то необходимо сформировать соответствующие импорты (объекты типа данных \textit{ImportDecl}). Определим функцию \lstinline{mkImport}(см. листинг~\ref{imp}), которая принимает строку (название модуля) и возвращает объект типа данных \textit{ImportDecl}. Объект создаётся путём заполнения полей соответствующего конструктора. Поскольку мы формируем простейший импорт модуля вида <<\lstinline{import ModuleName}>>, то все поля (кроме имени модуля) заполним константами, выражающими отсутствие значения.

\begin{ListingEnv}[h]
\begin{lstlisting}
mkImport :: String -> LImportDecl RdrName
mkImport module = 
             noLoc $ ImportDecl { ideclSourceSrc = Nothing
                                , ideclName      = noLoc 
                                $ mkModuleName module
                                , ideclPkgQual   = Nothing
                                , ideclSource    = False
                                , ideclSafe      = False
                                , ideclQualified = False
                                , ideclImplicit  = False
                                , ideclAs        = Nothing
                                , ideclHiding    = Nothing }
\end{lstlisting}
\caption{Формирование узла с импортом модуля}\label{imp}
\end{ListingEnv}

\subsection{Генерация экземпляров}
Для начала опишем общую функцию \lstinline{mkInstance} (см. листинг~\ref{mkinst}), которая принимает заголовок экземпляра, функции, определённые в экземпляре, и возвращает объект типа данных \textit{ClsInstDecl}.
Затем определим функции, которые по правилам, описанным в главе~\ref{instgen}, составляют список \lstinline{cid_binds}.
\begin{description}
\item[Экземпляр класса Applicative.] Для экземпляра класса \textit{Applicative} определим функцию \lstinline{mkCIDBindsForInstAppl} (см. листинг~\ref{cidbindsappl}), которая работает следующим образом. Она принимает два аргумента: определения функций \lstinline{return} и \lstinline{>>} из класса \textit{Monad}. Если реализация одной или обеих функций в экземпляре класса \textit{Monad} отсутствует, то соответствующая фукнция в классе \textit{Applicative} также не появится.
\item[Экземпляр класса Functor.] Для данного экземпляра зададим функцию \lstinline{mkCIDBindsForInstFunc} (см. листинг~\ref{cidbindsfunc}). Он не зависит от экземпляра класса \textit{Monad}, поэтому \lstinline{cid_binds} формируются всегда одним и тем же образом.
\end{description}

\begin{ListingEnv}[h]
\begin{lstlisting}
mkInstance :: LHsType RdrName -> LHsBinds RdrName
                                  -> ClsInstDecl RdrName
mkInstance insthead funs = ClsInstDecl { 
                              cid_poly_ty       = insthead
                            , cid_binds         = funs
                            , cid_sigs          = []
                            , cid_tyfam_insts   = []
                            , cid_datafam_insts = []
                            , cid_overlap_mode  = Nothing
                               }
\end{lstlisting}
\caption{Формирование узла с экземпляром}\label{mkinst}
\end{ListingEnv}

\section{Формирование выходного файла}
Сформировав новое синтаксическое дерево, применим к нему функцию структурной печати \lstinline{ppr}, которая находится в модуле \textit{Outputable} библиотеки GHC API (см. главу~\ref{ghcapi}). Данная функция принимает объект, тип данных которого имеет экземпляр класса \textit{Outputable} и возвращает объект типа данных \textit{SDoc}. Последний, в свою очередь, преобразовывается к строке с помощью специальных функций, например, \textit{showSDoc}, \textit{showSDocUnsafe} и других.

Опишем основную функцию (\lstinline{main}) (см. листинг~\ref{main}). Она работает следующим образом: принимает имя файла в качестве аргумента командной строки, проводит его синтаксический анализ, применяет к нему функцию \lstinline{appendAllInstances} (является композицией вышеописанных функций), затем печатает в результат в этот же файл.


\newpage
\chapter{Результаты работы программы}
Подадим на вход утилите тестовый файл \textit{Test.hs} и проанализируем результаты. Данный файл содержит несколько примеров экземпляра класса \textit{Monad}.

Рассмотрим первый пример: <<пустой>> экземпляр класса \textit{Monad}, т.~е. содержащий только заголовок.
\begin{figure}[H]
\begin{parcolumns}{2}
\colchunk[1]{\textbf{Исходные данные:}}
\colchunk[2]{\textbf{Результат:}}
\end{parcolumns}

\begin{minipage}{.45\textwidth}
\begin{lstlisting}
data MyData a = MyData a

instance Monad MyData
\end{lstlisting}
\end{minipage}
\begin{minipage}{.45\textwidth}
\begin{lstlisting}
data MyData a = MyData a

instance Applicative MyData where
  (<*>) = ap  
instance Functor MyData where
  fmap = liftM  
instance Monad MyData where
  return = pure
  (>>) = (*>)
\end{lstlisting}
\end{minipage}
\end{figure}
Результаты соответствуют ожидаемым: программой были добавлены экземпляры классов \textit{Functor} и \textit{Applicative}. Реализация функций \lstinline{pure} и \lstinline{*>} отсутствует, поскольку в экземпляре монады соответствующие идентично работающие функции реализованы не были.

Теперь рассмотрим пример, содержащий экземпляр класса \textit{Monad} с реализованными в нём функциями \lstinline{retrun} и \lstinline{>>=}. Кроме того, в исходном файле уже присутствовал экземпляр класса \textit{Functor}, в котором была определена функция \lstinline{fmap}.
\begin{figure}[!h]
\begin{parcolumns}{2}
\colchunk[1]{\textbf{Исходные данные:}}
\colchunk[2]{\textbf{Результат:}}
\end{parcolumns}

\begin{minipage}{.45\textwidth}
\begin{lstlisting}
newtype Prob a = Prob { 
        getProb :: [(a,Rational)] 
        } deriving Show

instance Functor Prob where  
    fmap f (Prob xs) = Prob 
            $ map (\(x,p) 
                -> (f x,p)) xs

flatten :: Prob (Prob a) -> Prob a  
flatten (Prob xs) = 
        Prob $ concat 
             $ map multAll xs  
    where 
        multAll (Prob innerxs,p) = 
          map (\(x,r) 
             -> (x,p*r)) innerxs

instance Monad Prob where  
  return x = Prob [(x,1%1)]  
  m >>= f 
    = flatten (fmap f m)
\end{lstlisting}
%$
\end{minipage}
\begin{minipage}{.45\textwidth}
\begin{lstlisting}
newtype Prob a = Prob {
  getProb :: [(a, Rational)]
  } deriving (Show)

instance Functor Prob where
  fmap f (Prob xs) = Prob 
        $ map (\ (x, p) 
            -> (f x, p)) xs
flatten :: Prob (Prob a) -> Prob a
flatten (Prob xs)
  = Prob $ concat 
         $ map multAll xs
  where
      multAll (Prob innerxs, p) 
        = map (\ (x, r) 
            -> (x, p * r)) innerxs

instance Applicative Prob where
  pure x = Prob [(x, 1 % 1)]
  (<*>) = ap

instance Monad Prob where
  return = pure
  (>>) = (*>)
  m >>= f 
    = flatten (fmap f m)
\end{lstlisting}
%$
\end{minipage}
\end{figure}

Результаты соответствуют ожидаемым:
\begin{enumerate}[1)]
\item <<лишний>> экземпляр класса \textit{Functor} не появился;
\item экземпляр класса \textit{Applicative} был сгенерирован в соответствии с требованиями (см. главу~\ref{generation});
\item экземпляр класс \textit{Monad} был изменён нужным образом;
\item изменения не затронули код, не относящийся к проблеме.
\end{enumerate}

\begin{ListingEnv}
\begin{lstlisting}
mkCIDBindsForInstAppl :: [HsBindLR RdrName RdrName]
                -> [HsBindLR RdrName RdrName] -> LHsBinds RdrName
mkCIDBindsForInstAppl [] [] = listToBag 
           [ noLoc (mkFunBind (mkFunId "(<*>)") 
                        ([mkLMatch [] $ mkGRHSs "ap"])) ]
                        
mkCIDBindsForInstAppl [] mongr = listToBag
           [ noLoc (mkFunBind (mkFunId "(<*>)") 
                        ([mkLMatch [] $ mkGRHSs "ap"]))
           , noLoc (mkFunBindForAppl "*>" (head mongr) True) ]
           
mkCIDBindsForInstAppl monret [] = listToBag
           [ noLoc (mkFunBindForAppl "pure" (head monret) False)
           , noLoc (mkFunBind (mkFunId "(<*>)") 
                         ([mkLMatch [] $ mkGRHSs "ap"])) ]
                         
mkCIDBindsForInstAppl monret mongr = listToBag
           [ noLoc (mkFunBindForAppl "pure" (head monret) False)
           , noLoc (mkFunBind (mkFunId "(<*>)") 
                         ([mkLMatch [] $ mkGRHSs "ap"]))
           , noLoc (mkFunBindForAppl "*>" (head mongr) True) ]
\end{lstlisting}
\caption{Формирование поля cid\_binds для Applicative}\label{cidbindsappl}
\end{ListingEnv}

\begin{ListingEnv}
\begin{lstlisting}
mkCIDBindsForInstFunc :: LHsBinds RdrName
mkCIDBindsForInstFunc = listToBag
    [ noLoc (mkFunBind (mkFunId "fmap") 
                          ([mkLMatch [] $ mkGRHSs "liftM"])) ]
\end{lstlisting}
\caption{Формирование поля cid\_binds для Functor}\label{cidbindsfunc}
\end{ListingEnv}
%$

\begin{ListingEnv}
\begin{lstlisting}
main :: IO ()
main = do
    dynFl <- GHC.runGhc (Just libdir) GHC.getSessionDynFlags
    [file] <- getArgs
    mp <- appendAllInstances $ parseHaskell file
    case mp of
        Nothing  -> putStrLn "Parse failed"
        Just mdl -> writeFile "a.hs" 
                $ showSDocUnsafe $ ppr mdl
\end{lstlisting}
\caption{Основная функция (main)}\label{main}
\end{ListingEnv}
%$

\Conc
В ходе работы над задачей было получено решение с применением библиотеки GHC API~--- программного интерфейса компилятора. Проанализировав результаты, можно прийти к следующим выводам.
\section*{Достоинства}
С помощью данного способа решения решается проблема обратной совместимости версий GHC младше, чем 7.10 и GHC 7.10. Поскольку были использованы стандартные функции библиотеки, которые учитывают все особенности двумерного синтаксиса языка \textit{Haskell}, на выходе получается код, который гарантированно скомпилируется.
\section*{Недостатки}
Однако у данного подхода имеются и недостатки.
\begin{enumerate}
\item Если в исходном файле присутствовали комментарии, то в выходном файле они не сохраняются, поскольку игнорируются при синтаксическом анализе. Однако данная утилита была создана в помощь программистам, которые хотят воспользоваться какими-либо сторонними библиотеками, то есть отсутствие комментариев в этом случае не так важно.
\item Гораздо более существенным недостатком является то, что конструкции \lstinline{case ... of} на выходе получаются синтаксически неверными, а именно, между вариантами отсутствует точка с запятой (см. листинг~\ref{error}). Это связано с наличием ошибки в исходном коде самого компилятора: функции структурной печати (\textit{pretty printing}), описанные в GHC API, используют вариант конструкции с фигурными скобками, который предполагает наличие точек с запятой, однако они не добавляются. Тем не менее, эта проблема в данный момент решается: нами инициирован процесс добавления соответствующих изменений в общедоступный код компилятора GHC.
\end{enumerate}

\begin{ListingEnv}[h]
    \begin{lstlisting}
f mp = case mp of {
           Nothing -> 1 -- missing ;
           Just _ -> 2 }
    \end{lstlisting}
\caption{Синтаксическая ошибка}\label{error}
\end{ListingEnv}

% Печать списка литературы (библиографии)
\printbibliography[%{}
    heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

%\appendix
%\ifthenelse{\value{worktype} > 1}{%
  %\addtocontents{toc}{%
      %\protect\renewcommand{\protect\cftchappresnum}{\appendixname\space}%
      %\protect\addtolength{\protect\cftchapnumwidth}{\widthof{\appendixname\space{}} - \widthof{Глава }}%
  %}%
%}{
  %\addtocontents{toc}{%
      %\protect\renewcommand{\protect\cftsecpresnum}{\appendixname\space}%
      %\protect\addtolength{\protect\cftsecnumwidth}{\widthof{\appendixname\space{}}}%
  %}%
%}

%\section{Пример работы программы}

%Здесь длинный листинг с примером работы.

\end{document}
