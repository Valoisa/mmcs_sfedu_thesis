% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (section) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}
\hyphenation{Monad Applicative Functor Control Data}
    \tikzstyle{every node}=[shape=rectangle, color=black, rounded corners,%
    text=black, anchor=west]
    \tikzstyle{selected}=[shape=rectangle, rounded corners,%
    top color=gray,%
    bottom color=gray, text=white]
    \tikzstyle{optional}=[dashed,fill=gray!50]

\begin{document}

\Intro
\section*{Цель работы}
\section*{Постановка задачи}

\chapter{Предварительные сведения}

\chapter{Алгоритм выведения типов}
\section{Основные понятия}
Для начала введём основные термины, которые будут использоваться при описании алгоритма выведения типов.
\begin{description}
	\item[Компонент.] Компонентами являются встроенные функции. <Добавить также изображение компонента>
	\item[Функция.] Если не указано иное, функцией будем называть определённую пользователем функцию.
	\item[Вызывающий компонент (caller).] Компонент, предназначающийся для использования определённой пользователем функции.
	\item[Связь (connection).]
	\item[Вход (connection point).] Вход компонента соответствует одному аргументу функции. На вход можно подать значение (одно из возможных значений типа, который назначен данному входу) либо другой компонент. Компонент может не иметь входов, если это: 
	\begin{enumerate}[1)]
		\item аргумент определяемой пользователем функции;
		\item вызывающий компонент (caller) пользовательской функции без аргументов.
	\end{enumerate} 
	\item[Контекст.] description
	\item[Инферер (inferer).] description
	\item[Алиас (alias).] description
\end{description}
 
\chapter{Проблемы и их решения}

\chapter{Детали реализации}

\chapter{Кодогенерация}
\section{Постановка задачи кодогенерации}
Для программы на визуальном языке сгенерировать соответствующий ей код на языке Haskell. Полученный код должен компилироваться с помощью GHC. Затем корневая функция исполняется и её результат передаётся в основную программу.
\section{План решения}
\section{Программные средства}
Для решения данной задачи было решено использовать следующие средства языка Haskell.

	\subsection{Template Haskell (TH)} Template Haskell --- стандартный фреймворк, предоставляющий средства для типобезопасного метапрограммирования на языке Haskell, обрабатываемые на этапе компиляции компилятором GHC. [ссылка на хаскель вики]  TH позволяет писать мета-программы на языке Haskell, результатом выполнения которых являются другие программы на языке Haskell. Данный фреймворк применяется для кодогенерации во времени выполнения а также для создания доменно-специфичных языков. Для решения нашей задачи нам потребуется возможность сгенерировать синтаксическое дерево (представляемое специальными типами данных) и получить его строковое представление (т.е. в виде программного кода на языке Haskell) с помощью функций структурной печати (англ. \textit{pretty-printing}).
	% Библиотека для метапрограммирования на языке Haskell. Предоставляет возможность генерировать код на языке Haskell с помощью специальных типов данных, затем возвращать его строковое представление с помощью функций структурной печати (\textit{pretty-printing}). Не гарантирует, что сгенерированный таким образом код пройдёт проверку системы типов. Однако будем предполагать, что такую гарантию нам даёт наш собственный алгоритм выведения типов.
	\subsection{GHC API} API компилятора GHC. Для решения поставленной задачи мы воспользуемся такими возможностями этой библиотеки, как создание контекста и привнесение в него определений (которые мы будем генерировать с помощью Template Haskell), а также исполнение функций интерпретатором. 
	\subsection{Foreign Function Interface (FFI)} Это расширение стандарта языка Haskell. Оно позволяет программам на языке Haskell взаимодействовать с программами, написанными на других языках. Таким образом, с помощью этого расширения программы на языке Haskell могут вызывать программы, написанные на других языках, и наоборот: программы на различных языках получают возможность вызывать программы на языке Haskell. В нашем случае мы будем использовать средства взаимодействия с языком C. 
	
	\subsubsection{Соглашение о вызове} Для того, чтобы взаимодействовать с кодом, написанным на другом языке, необходимо знать \textit{соглашение о вызове} (англ. \textit{calling convention}), использующееся реализацией другого языка в текущей архитектуре. С помощью FFI компилятор языка Haskell GHC поддерживает стандартные соглашения о вызове, такие как \lstinline{cdecl}, \lstinline{pascal} и другие. Например, пусть при объявлении функции, предназначенной для другого языка программирования, указано соглашение о вызове \lstinline{cdecl}. Тогда GHC сгенерирует такой код, при исполнении которого параметры будут расположены в памяти и в регистрах таким образом, как того ожидает компилятор языка C (или любой другой компилятор, использующий то же соглашение о вызове). А именно, аргументы функций передаются справа налево; очистку стека производит вызывающая программа.
	
	Соглашение о вызове зависит от типов параметров. Только некоторые типы данных языка Haskell могут быть напрямую использованы для функций, предназначенных для других языков, потому что эти типы данных отвечают базовым типам данных низкоуровневых языков программирования. Рассмотрим некоторые типы данных, которые будут нами позднее использованы.
	
	\subsubsection{Основные используемые типы данных} Значение типа \lstinline{Ptr a} представляет собой указатель на объект или массив объектов, который может быть маршалирован (англ. \textit{marshalled}) в значения языка Haskell типа \lstinline{a} (или наоборот, из массива значений языка Haskell в массив значений другого языка). Тип данных \lstinline{a}, как правило, является экземпляром класса \lstinline{Storable}, который предоставляет операции маршалинга (англ. \textit{marshalling}). Однако это не существенно: пользователь может реализовать собственные операции доступа к указателю.
	
	Также нам понадобится тип данных \lstinline{CWString}. Он является синонимом типа данных \lstinline{Ptr CWchar} и представляет собой указатель на массив символов в кодировке Unicode в языке C, завершающийся пустым символом (т.е. \lstinline{wchar_t*} в языке C).
	
	\textit{Устойчивый указатель} (англ. \textit{stable pointer}) --- это ссылка на выражение языка Haskell, значение которого сборщиком мусора гарантировано не будет ни удалено (т.~е. память, выделенная под него, не будет освобождена), ни перемещено в другую область памяти. Таким образом, устойчивые указатели могут быть переданы в код на другом языке программирования, который будет обращаться с ними как с ссылками на значения языка Haskell, закреплённые в памяти (аналогом такой конструкции можно считать закреплённый указатель (англ. \textit{pinned pointer}) в языке C\#). Таким образом, мы сможем создать контекст, представленный монадой \textit{Ghc}, создать устойчивый указатель на него, а затем использовать его в языке C. Со стороны языка C мы будем манипулировать им как указателем типа~\lstinline{void*}.   % Библиотека языка Haskell, которая позволяет создавать функции на языке Haskell, предназначенные для исполнения их на другом языке программирования (в данном случае C/C++). Позволяет работать с некоторыми типами данных языков C/C++, в том числе позволяет создавать указатели, что нам пригодится для работы с контекстом.


\chapter{Тестирование}
\section{Тест <<Переприсоединение>>}
Тест <<Переприсоединение>> (англ. \textit{test-reconnect}) был задумал с целью автоматизации проверки того, что состояние инферера каждого компонента остаётся прежним после удаления и восстановления одной из входящих связей.
\section{Тест <<Все ко всем>>}
Тест <<Все ко всем>> (англ. \textit{all-to-all test}) воспроизводит попытки создания всевозможных связей для каждого конкретного примера. Это необходимо для проверки того, что все ошибочные ситуации обрабатываются правильно. К ошибочным ситуациям относятся:
\begin{itemize}
	\item попытка создания связи, которая приводит к циклу в синтаксическом дереве;
	\item попытка создания связи, которая приводит к появлению бесконечного типа;
\end{itemize}


% Печать списка литературы (библиографии)
\printbibliography[%{}
    heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

%\appendix
%\ifthenelse{\value{worktype} > 1}{%
  %\addtocontents{toc}{%
      %\protect\renewcommand{\protect\cftchappresnum}{\appendixname\space}%
      %\protect\addtolength{\protect\cftchapnumwidth}{\widthof{\appendixname\space{}} - \widthof{Глава }}%
  %}%
%}{
  %\addtocontents{toc}{%
      %\protect\renewcommand{\protect\cftsecpresnum}{\appendixname\space}%
      %\protect\addtolength{\protect\cftsecnumwidth}{\widthof{\appendixname\space{}}}%
  %}%
%}

%\section{Пример работы программы}

%Здесь длинный листинг с примером работы.

\end{document}
