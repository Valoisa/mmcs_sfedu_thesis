% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (section) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}
\hyphenation{Monad Applicative Functor Control Data}
    \tikzstyle{every node}=[shape=rectangle, color=black, rounded corners,%
    text=black, anchor=west]
    \tikzstyle{selected}=[shape=rectangle, rounded corners,%
    top color=gray,%
    bottom color=gray, text=white]
    \tikzstyle{optional}=[dashed,fill=gray!50]

\begin{document}

\Intro
\section*{Предварительные сведения}
\section*{Цель работы}
\section*{Постановка задачи}

%\chapter{Предварительные сведения}

\chapter{Алгоритм вывода типов}
\section{Основные понятия}
Для начала введём основные термины, которые будут использоваться при описании алгоритма вывода типов.
\begin{description}
	\item[Компонент.] Компонентами являются встроенные функции. Примеры компонентов: см. рис. \ref{components}.
	\item[Функция.] Если не указано иное, функцией будем называть определённую пользователем функцию. Пример функции: см. рис. \ref{customfun}.
	\item[Вызывающий компонент (caller).] Компонент, предназначающийся для использования определённой пользователем функции.
	\item[Вход (connection point).] Вход компонента соответствует одному аргументу функции, которой отвечает компонент. На вход можно подать значение (одно из возможных значений типа, который назначен данному входу) либо другой компонент. Компонент может не иметь входов, если это: 
	\begin{enumerate}[1)]
		\item аргумент определяемой пользователем функции;
		\item вызывающий компонент (caller) пользовательской функции без аргументов.
	\end{enumerate} 
	\item[Связь (connection).] Если один компонент подан другому на вход в качестве аргумента, то будем говорить, что между этими компонентами существует связь. Также между компонентами может существовать неявная связь, если явной связи (в виде стрелочки) нет, то, тем не менее, изменения в одном компоненте приводят к изменениям в другом. Такая связь существует между функцией и её вызывающим компонентом.
	\item[Унификация (unify).] Две переменные типа унифицированы, если их ограничения не противоречат друг другу. Если две переменные унифицированы, то это значит, что они взаимозаменяемы.
	\item[Ограничение (constraint).] Будем говорить, что переменная имеет ограничение, если выполняется одно или более из условий:
		\begin{enumerate}[1)]
			\item переменная унифицирована с одной или более другими переменными;
			\item переменная принадлежит одному или нескольким классам типов;
			\item переменная имеет конкретный тип (например, \lstinline!Int!, \lstinline!Bool!, \lstinline!Char! и т.д.).
		\end{enumerate}  
	Ограничения могут противоречить друг другу. Например, если на переменную, принадлежащую классу типов \textit{Num} по валидной на данный момент связи придёт тип \textit{Char}. В таком случае связь, по которой пришли противоречивые ограничения и компонент, в который они пришли, объявляются мёртвыми (dead). В IDE это отображается красным цветом (см. рис. \ref{dead}).
	\item[Контекст.] Контекстом будем называть набор всех ограничений на все переменные отдельно взятого компонента. Каждый компонент имеет свой отдельный контекст.
	\item[Идентификатор входа.] Для того, чтобы различать, какая переменная контекста какому входу соответствует введём идентификаторы входов. Идентификатора входа однозначно идентифицирует номер входа конкретного компонента; входы компонентов нумеруются с нуля.
	\item[Собственные переменные.] Собственными переменными контекста будем называть те переменные, которые находились в контексте с момента создания компонента.
	\item[Импортированые переменные.] Импортированными переменными будем называть те переменные, которые попали в текущий контекст по связям из контекстов других компонентов.
	\item[Параметр.] При описании алгоритма вывода типов переменную типа для удобства будем называть параметром.
	\item[Конкретный тип (value type).] К конкретным типам отнесём типы \lstinline|Int|, \lstinline|Float|, \lstinline|Char|, \lstinline|Bool|, а также кортежи \lstinline|(a1, a2, ...)|, списки \lstinline|[a]|, и тому подобное. Таким образом, внутри конкретного типа могут иметься другие типы.
	%\item[Инферер (inferer).] description
	\item[Псевдоним (alias).] Новое имя, которое может получить параметр в процессе вывода типов.
\end{description}

\begin{figure}[h]
	\centering
	\includegraphics{img/components.PNG}
	\caption{Примеры компонентов}\label{components}	
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics{img/custom_function.PNG}
	\caption{Пример функции, определённой пользователем}\label{customfun}	
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics{img/dead.PNG}
	\caption{Пример мёртвого компонента}\label{dead}
\end{figure}

\section{Общие правила}
Пусть имеется дерево программы, в котором уже произошёл вывод типов. Предположим, что какой-то компонент инициировал новый вывод типов, т.\,е. произошло одно из следующих событий:
\begin{enumerate}[1)]
	\item была убрана или добавлена какая-либо связь со входом этого компонента;
	\item по уже существующей связи пришли новые данные (ограничения), т.\,е. изменение произошло в более левом компоненте, и до текущего дошло обновление;
	\item на какой-либо из переменных компонента был явно указан новый тип;
	\item если данный компонент вызывающий, то изменился тип аргументов или результата функции, которую он вызывает.
\end{enumerate}
Допустим также, что этот вывод затронул тип результата компонента. Тогда дальше вывод типов будет происходить во всех компонентах, связь к которым идёт от текущего. Этот процесс назовём \textit{пропагацией} (от англ. \textit{propagation}~--- распространение). Если же в процессе вывода типов результат компонента не изменился, тогда пропагация останавливается. Результат компонента мог не измениться по следующим причинам:
\begin{enumerate}[1)]
	\item результат имеет конкретный тип, не зависящий от входов;
	\item произошедшие изменения не добавили никаких принципиально новых ограничений на переменную типа результата.
\end{enumerate}
Также пропагация останавливается в том случае, если обновление дошло до компонента, не имеющего исходящих связей (ни явных, ни неявных).

Пусть в контексте какого-либо компонента есть несколько переменных. Пусть $a_1, a_2, \ldots, a_n$~--- \textit{собственные} переменные текущего контекста, $b_1, b_2, \ldots, b_m$~--- \textit{импортированные} переменные. И пусть какие либо переменные $a_{i_1}, a_{i_2}, \ldots, a_{i_k}$ и $b_{j_1}, b_{j_2}, \ldots, b_{j_l}$ унифицированы с переменной результата. Нужно принять решение, какие из этих переменных будут скопированы в другой контекст, один или несколько входов которого связаны с результатом текущего. Тогда копироваться будут все переменные, кроме собственных переменных контекста, т.\,е. $b_{j_1}, b_{j_2}, \ldots, b_{j_l}$.

\section{Алгоритм вывода типов в простейшем случае}
Теперь рассмотрим алгоритм вывода типов в отдельно взятом компоненте. В таком случае возможно 3 варианта, в которых мы будем действовать по-разному. Рассмотри пример простейшей связи двух компонентов, рис. \ref{connection}. Контекст правого компонента будем считать текущим. Контекст левого компонента назовём \textit{внешним}.
\begin{figure}
\centering
\includegraphics{img/connection.PNG}
\caption{Пример простейшей связи двух компонентов}\label{connection}
\end{figure}
\subsection{Параметр против параметра}
Пусть в текущем контексте имеется параметр, на котором уже есть ограничения. Обозначим этот параметр $a_n$, где $n$~--- идентификатор входа этого параметра. Пусть через вход компонента, соответствующего идентификатору входа $n$, попадает другой параметр, со своим набором ограничений, обозначим его $b_n$. Нам нужно принять решение, можно ли унифицировать $a_n$ и $b_n$. Для этого ограничения на этих параметрах проверяются на непротиворечивость по следующему алгоритму.
\begin{enumerate}
	\item Собрать все ограничения, которые имеются на $a_n$. Для этого нужно также собрать все известные ограничения на переменных, с которыми $a_n$ унифицирован.
	\item То же самое проделать для $b_n$ и переменных, с которыми он унифицирован во внешнем контексте.
	\item Проверить, что классы типов, которым принадлежат $a_n$ и $b_n$ не противоречат друг другу (если они имеются). Для этого множество классов типов $b_n$ должно быть подмножеством классов типов $a_n$.
	\item Проверить, что конкретные типы, если таковые имеются, друг другу не противоречат, см. подглаву \ref{valueVSvalue}.
\end{enumerate}
\subsection{Конкретный тип против параметра}
Пусть нужно провести вывод параметра против конкретного типа. Обозначим параметр как $a_n$, где $n$~--- идентификатор входа, конкретный тип как $Val_1(x_1, x_2, \ldots, x_m)$. Тогда алгоритм будет заключаться в следующем.
\begin{enumerate}
	\item Если $a_n$ не принадлежит текущему контексту (например, зашёл в текущий компонент по связи), тогда копируем его в текущий контекст.
	\item Собираем все известные ограничения параметра $a_n$.
	\item Проверяем, что классы типов, которым принадлежит параметр, не противоречат классам типов, экземпляром которых является $Val_1(x_1, x_2, \ldots, x_m)$. Это означает, что множество классов типов, которым принадлежит $a_n$, должно быть подмножеством классов типов, экземпляром которых является $Val_1(x_1, x_2, \ldots, x_m)$. Если это не так, тогда алгоритм типов прерывается, связь и компонент объявляются мёртвыми.
	\item Если на параметре имеется ограничение в виде конкретного типа $Val_2(y_1, y_2, \ldots, y_k)$, то см. главу \ref{valueVSvalue}. Если вывод $Val_1(x_1, x_2, \ldots, x_m)$ на $Val_2(y_1, y_2, \ldots, y_k)$ завершился с ошибкой, то связь и компонент объявляются мёртвыми и вывод типов прерывается.
	\item Если на предыдущих шагах не возникло ошибки, тогда на параметр $a_n$ добавляется ограничение в виде конкретного типа $Val_1(x_1, x_2, \ldots, x_m)$.
	\item Для каждого $x_i, i = 1 .. m$ необходимо выполнить следующие действия. Если $x_i$~--- это параметр:
		\begin{enumerate}[1)]
			\item если $x_i$ уже есть в текущем контексте, провести вывод типов параметр против параметра; если он завершился с ошибкой, тогда вывод типов останавливается;
			\item если $x_i$ нет в текущем контексте, тогда скопировать его в текущий контекст со всеми ограничениями. Пометить этот параметр (см. замечание \ref{rem_rec_types}).
		\end{enumerate}	
	Допустим теперь, что $x_i$~--- конкретный тип. Обозначим его $Val_3(z_1, z_2, \ldots, z_l)$:
		\begin{enumerate}[1)]
			\item если $l = 0$, т.\,е $Val_3$ имеет род $*$, тогда ничего делать не нужно;
			\item если же $Val_3$ имеет род $* \rightarrow \ldots \rightarrow *$, тогда выполнить для него пункт 6.
		\end{enumerate}
	\item Если ни на каком из предыдущих шагов не возникло ошибки, тогда алгоритм завершается успешно (см. замечание \ref{rem_fur_prop}).
\end{enumerate}

\myremark{
	Поясним, для чего нужно помечать параметры. Дело в том, что при выводе типов для рекурсивной функции есть опасность получить бесконечный тип. Например, если на параметр $a_n$ добавить ограничение $[a_n]$, то мы получим бесконечное множество раз вложенный список. Допустим, параметр $a_n$ помечен. Тогда при попытке пометить его второй раз, уже в качестве внутреннего параметра списка, станет ясно, что мы имеем дело с бесконечным типом. В таком случае вывод типов прерывается, связь и текущим компонент объявляются мёртвыми.
}\label{rem_rec_types}

\myremark{
	Алгоритм завершается успешно, если в процессе вывода типов не было выявлено противоречий. Это означает, что возможна дальнейшая пропагация типов.
}\label{rem_fur_prop}

\subsection{Конкретный тип против конкретного типа}\label{valueVSvalue}
Пусть в текущем контексте имеется конкретный тип, который обозначим $Val_1 (x_1, x_2, \ldots, x_k)$, где $x_1, x_2, \ldots, x_k$~--- внутренние параметры или внутренние конкретные типы $Val_1$. Их может и не быть, если тип имеет род $*$ (англ. \textit{kind}). Пусть теперь через вход, соответствующий идентификатору входа $n$, поступает конкретный тип $Val_2 (y_1, y_2, \ldots, y_l)$. Нам необходимо убедиться, что эти типы друг другу не противоречат.
\begin{enumerate}
	\item Убедимся, что $Val_1$ и $Val_2$ являются конструкторами одного и того же типа. Если это так, и, кроме того, они имеют род $*$, тогда алгоритм завершается успешно. Если же типы имеют род $* \rightarrow \ldots \rightarrow *$, тогда переходим на шаг 2.
	\item Проверим, что $k == l$, т.\,е. что количества внутренних типов совпадают. Например, если и $Val_1$, и $Val_2$ представляют собой конструкторы кортежей $Tuple$, то нужно проверить, что это кортежи из одинакового количества элементов. Если это не так, тогда алгоритм завершается, а связь и текущий компонент помечаются мёртвыми.
	\item Для каждой пары типов $(x_i, y_i), i = 1 .. k$ применить соответствующий ей простейший алгоритм вывода типов.	Но перед этим каждый из этих параметром необходимо \textit{пометить} (см. замечание \ref{rem_rec_types}).
\end{enumerate}

\section{Алгоритм определения порядка обновления компонентов в дереве}
Рассмотрим синтаксическое дерево программы языка с точки зрения теории графов. Здесь \textit{вершины}~--- это компоненты, \textit{дуги}~--- это связи между компонентами. Вспомним, что связь может быть:
	\begin{enumerate}[1)]
		\item явной, т.\,е. стрелкой между результатом одного компонента и входом другого;
		\item неявной, такая связь имеется между функцией и её вызывающим компонентом.
	\end{enumerate}
Поскольку функция может быть рекурсивной, на графе могут присутствовать циклы. Кроме того, могут также быть определены функции, которые нигде не вызываются. Это значит, что подграф этой функции может не иметь исходящих связей. Предположим также, что ни один компонент из корня не участвует в определении функции, то есть её подграф не имеет и входящих связей. Таким образом, граф программы может быть несвязным.

Итак, пусть какой-либо компонент в дереве инициировал обновление. Прежде чем начать вывод типов, определим, какие компоненты могут быть затронуты в результате этого изменения. Нам нужно получить упорядоченный список компонентов, чтобы затем согласно этому списку проводить пропагацию. Получим его с помощью следующего алгоритма.
\begin{enumerate}
	\item Для начала нужно получить список всех компонентов, достижимых из компонента-инициатора. Компонент является достижимым, если до него существует путь по дугам нашего графа. Получим такой список с помощью известного алгоритма \textit{поиска в глубину} [ссылка на алгоритм].
	\item Теперь у нас есть подграф всех компонентов, достижимых из инициатора. Обозначим этот подграф $G(V, E)$, где $V$~--- это множество вершин, $E$~--- множество дуг. Построим \textit{конденсацию} этого подграфа. Пусть $C(V', E')$~-- конденсация, $V'$~--- её вершины, $E'$~--- её дуги. Вершинами являются \textit{компоненты сильной связности} графа (см. замечание \ref{rem_ssc}). Дуга от $V_i \in V'$ к $V_j \in V'$ проводится, если найдутся такие вершины $u, v \in V$, что $u \in V_i, v \in V_j$, и существует дуга $(u, v)$.
	\item Строим \textit{топологическую сортировку} конденсации $C(V', E')$. Поскольку компоненты, не принадлежащие циклам, образуют отдельные КСС (см. замечание \ref{rem_ssc}), то порядок обновления этих компонентов будет таким же, как порядок соответствующих КСС в топологической сортировке.
	\item Внутри КСС, содержащих циклы, порядок обновления компонентов определяется следующим образом. Допустим, инициатор находится вне цикла. Пусть пропагация обновлений дошла до одного из компонентов цикла, по отношению к циклу он является инициатором. Тогда строим топологическую сортировку для подграфа текущей КСС без нового компонента-инициатора.
\end{enumerate}

\myremark{
	В нашем случае может быть два типа компонент сильной связности. Первый тип~--- КСС, состоящая из единственного компонента. Второй тип~--- цикличный подграф рекурсивной (возможно взаимнорекурсивной) функции(й). Таким образом, в КСС может быть либо ровно один компонент, либо не менее трёх (в случае простейшей рекурсивной функции: результат этой функции, сама функция, её вызывающий компонент внутри её тела).
}\label{rem_ssc}
%\subsection{Проверка типов на независимость}
%В процессе вывода типов рекурсивной 

%\chapter{Проблемы и их решения}

\chapter{Детали реализации}

\chapter{Кодогенерация}
\section{Постановка задачи кодогенерации}
Для программы на визуальном языке сгенерировать соответствующий ей код на языке Haskell. Полученный код должен компилироваться с помощью GHC. Затем корневая функция должна вычислиться, а её результат~--- передаться в основную программу.
\section{План решения}
Решение поставленной задачи состоит из следующих шагов.
\begin{enumerate}[1.]
	\item На стороне Haskell:
		\begin{enumerate}[1)]
			\item создавать GHC-контекст, в который помещать определения функций из стандартных модулей (включая базовый модуль Prelude);
			\item генерировать код на основе данных, полученных из основной программы;
			\item компилировать полученный код и помещать в созданный на шаге 1.1 контекст новые определения;
			\item вызывать требуемую функцию и её результат передавать в основную программу;
			\item если выполнение или компиляция завершились с ошибкой, т.\,е. произошёл выброс исключения, сообщить об этом основной программе.
		\end{enumerate}
	\item На стороне C++:
		\begin{enumerate}[1)]
			\item передать стороне Haskell данные для генерации кода;
			\item получить результат вычисления требуемой функции.
		\end{enumerate}
\end{enumerate}
\section{Программные средства}
Для решения данной задачи было решено использовать следующие средства языка Haskell.

	\subsection{Template Haskell (TH)}\label{temphassec} Template Haskell~--- стандартный фреймворк, предоставляющий средства для типобезопасного метапрограммирования на языке Haskell, обрабатываемые на этапе компиляции компилятором GHC~\autocite{temphas}. TH позволяет писать мета-программы на языке Haskell, результатом выполнения которых являются другие программы на языке Haskell. Данный фреймворк применяется для кодогенерации во времени выполнения а также для создания доменно-специфичных языков. Для решения нашей задачи нам потребуется возможность сгенерировать синтаксическое дерево (представляемое специальными типами данных) и получить его строковое представление (т.\,е. в виде программного кода на языке Haskell) с помощью функций структурной печати (англ. \textit{pretty-printing}).
	
	\subsubsection{Основные используемые типы данных} Для кодогенерации нам понадобятся следующие типы данных: \lstinline!data Exp! и \lstinline!data Dec!. Первый из них представляет собой тип данных, отвечающим \textit{выражению} на языке Haskell, т.\,е. этим типом данных описываются переменные, литералы, применения функций, условные выражения и т.д. (см. табл. \ref{expconstr}). Второй описывает \textit{определения} на языке Haskell, например, функции, определения новых типов данных, классов типов, синонимов типов и др. (см. табл. \ref{decconstr}).
	
	\subsubsection{Возможные проблемы} Среди программистов на языке Haskell использование TH считается небезопасным~\autocite{ugly}. Этому есть причины. Например, с помощью TH можно сгенерировать такой код, который не будет компилироваться (не пройдёт проверку типов)~\autocite{whatsbad}. Тем не менее, мы будем предполагать, что алгоритм вывода типов нашего визуального языка работает корректно, а потому сгенерированный таким образом код будет рабочим.
	
\begin{table}[h]
	\begin{center}
		\begin{tabular}{ll}
			{\lstinline!VarE Name!} & имя переменной \\
			{\lstinline!ConE Name!} & имя конструктора типа данных \\
			{\lstinline!LitE Lit!} & литерал (числовой или символьный) \\
			{\lstinline!AppE Exp Exp!} & применение функции \\
			{\lstinline!InfixE (Maybe Exp) Exp (Maybe Exp)!} & бинарная операция, возможно, \\ & частично применённая \\
			{\lstinline!LamE [Pat] Exp!} & лямбда-выражение \\
			{\lstinline!TupE [Exp]!} & кортеж \\
			{\lstinline!CondE Exp Exp Exp!} & условное выражение \\
			{\lstinline!ListE [Exp]!} & список \\
		\end{tabular}
	\end{center}
\caption{Некоторые конструкторы типа данных Exp}
\label{expconstr}
\end{table}

\begin{table}[h]
\begin{center}
	\begin{tabular}{ll}
		{\lstinline!FunD Name [Clause]!} & определение функции \\
										 & {\lstinline!func x y = ...!} \\
		{\lstinline!SigD Name Type!} & прототип (сигнатура) функции \\
									 & {\lstinline!func :: a -> a -> a!}
	\end{tabular}
\end{center}
\caption{Некоторые конструкторы типа данных Dec}
\label{decconstr}
\end{table}
	% Библиотека для метапрограммирования на языке Haskell. Предоставляет возможность генерировать код на языке Haskell с помощью специальных типов данных, затем возвращать его строковое представление с помощью функций структурной печати (\textit{pretty-printing}). Не гарантирует, что сгенерированный таким образом код пройдёт проверку системы типов. Однако будем предполагать, что такую гарантию нам даёт наш собственный алгоритм вывода типов.
	\subsection{GHC API~--- программный интерфейс компилятора}\label{ghcapisec} Функционал GHC может быть использован не только для компиляции программ на языке Haskell. Важным примером использования может послужить анализ и, возможно, преобразование кода на языке Haskell. Другим примером является динамическая загрузка кода, как	в GHCi~\autocite{GHClib}. Для этих целей функционал GHC доступен через библиотеку GHC API.
	
	Рассмотрим некоторые модули этой библиотеки, функционал которых применялся в данной работе.
	\begin{description}
		\item[InteractiveEval.] Предоставляет функции для манипуляции выражениями языка Haskell, в том числе и для их исполнения. Работа с выражениями происходит в специально создающемся для этого контексте интерактивных вычислений (англ. interactive evaluation context). Этот контекст содержит все определения, которые в него были помещены. В него можно импортировать и определения стандартных модулей.
		\item[DynFlags.] В этом модуле описаны параметры компиляции. Большинство флагов являются динамическими. Это означает, что они могут изменяться от одного процесса компиляции к другому.
		\item[HsImpExp.] Здесь содержатся типы данных и функции, предназначенные для работы с импортом модулей. Модуль в языке Haskell можно подключить различными способами: стандартным образом (т.\,е. использовать все определения из него), импортируя только конкретные функции, запрещая импортировать некоторые функции и так далее. Функционал модуля HsImpExp позволяет это сделать, например, для интерактивного контекста.
		\item[GHC.] Модуль, посвящённый работе с монадой GHC. Это монада, содержащая весь функционал, необходимый для вызовов функций GHC API. 
	\end{description} 

	Более подробно см. документацию по GHC API~\autocite{apidoc}. % API компилятора GHC. Для решения поставленной задачи мы воспользуемся такими возможностями этой библиотеки, как создание контекста и привнесение в него определений (которые мы будем генерировать с помощью Template Haskell), а также исполнение функций интерпретатором. 
	\subsection{Foreign Function Interface (FFI)} Это расширение стандарта языка Haskell. Оно позволяет программам на языке Haskell взаимодействовать с программами, написанными на других языках. Таким образом, с помощью этого расширения программы на языке Haskell могут вызывать программы, написанные на других языках, и наоборот: программы на различных языках получают возможность вызывать программы на языке Haskell~\autocite{ffi}. В нашем случае мы будем использовать средства взаимодействия с языком C. 
	
	\subsubsection{Соглашение о вызове} Для того, чтобы взаимодействовать с кодом, написанным на другом языке, необходимо знать \textit{соглашение о вызове} (англ. \textit{calling convention}), использующееся реализацией другого языка в текущей архитектуре. С помощью FFI компилятор языка Haskell GHC поддерживает стандартные соглашения о вызове, такие как \lstinline{cdecl}, \lstinline{pascal} и другие. Например, пусть при объявлении функции, предназначенной для другого языка программирования, указано соглашение о вызове \lstinline{cdecl}. Тогда GHC сгенерирует такой код, при исполнении которого параметры будут расположены в памяти и в регистрах таким образом, как того ожидает компилятор языка C (или любой другой компилятор, использующий то же соглашение о вызове). А именно, аргументы функций передаются справа налево; очистку стека производит вызывающая программа.
	
	Соглашение о вызове зависит от типов параметров. Только некоторые типы данных языка Haskell могут быть напрямую использованы для функций, предназначенных для других языков, потому что эти типы данных отвечают базовым типам данных низкоуровневых языков программирования. Рассмотрим некоторые типы данных, которые будут нами позднее использованы.
	
	\subsubsection{Основные используемые типы данных} Значение типа \lstinline{Ptr a} представляет собой указатель на объект или массив объектов, который может быть маршалирован (англ. \textit{marshalled}) в значения языка Haskell типа \lstinline{a} (или наоборот, из массива значений языка Haskell в массив значений другого языка). Тип данных \lstinline{a}, как правило, является экземпляром класса \lstinline{Storable}, который предоставляет операции маршалинга (англ. \textit{marshalling}). Однако это не существенно: пользователь может реализовать собственные операции доступа к указателю.
	
	Также нам понадобится тип данных \lstinline{CWString}. Он является синонимом типа данных \lstinline{Ptr CWchar} и представляет собой указатель на массив символов в кодировке Unicode в языке C, завершающийся пустым символом (т.\,е. \lstinline{wchar_t*} в языке C).
	
	\textit{Устойчивый указатель} (англ. \textit{stable pointer})~--- это ссылка на выражение языка Haskell, значение которого сборщиком мусора гарантировано не будет ни удалено (т.~е. память, выделенная под него, не будет освобождена), ни перемещено в другую область памяти. Таким образом, устойчивые указатели могут быть переданы в код на другом языке программирования, который будет обращаться с ними как с ссылками на значения языка Haskell, закреплённые в памяти (аналогом такой конструкции можно считать закреплённый указатель (англ. \textit{pinned pointer}) в языке C\#). Таким образом, мы сможем создать контекст, представленный монадой \textit{Ghc}, создать устойчивый указатель на него, а затем использовать его в языке C. Со стороны языка C мы будем манипулировать им как указателем типа~\lstinline{void*}.   % Библиотека языка Haskell, которая позволяет создавать функции на языке Haskell, предназначенные для исполнения их на другом языке программирования (в данном случае C/C++). Позволяет работать с некоторыми типами данных языков C/C++, в том числе позволяет создавать указатели, что нам пригодится для работы с контекстом.

\section{Решение и детали реализации решения}
Программный код кодогенератора разбит на несколько модулей. 
\begin{description}
	\item[Compilation.hs:] содержит функции для создания и работы с GHC-контекстом, для компиляции и вычисления выражений, функции-<<обёртки>>, предназначенные для вызова в языке C.
	\item[Generator.hs:] здесь определены функции для генерации кода на языке Haskell и все необходимые для этого типы данных.
	\item[HSCodeGen.cpp:] в этом модуле содержатся функции уже языка C, которые вызывают соответствующие им функции языка Haskell.
\end{description}
	\subsection{Создание GHC-контекста}
		Для начала создадим GHC-контекст, куда поместим определения из стандартных модулей. Для этого определим функцию \lstinline!mkModuleImport!, которая принимает строку, а возвращает \lstinline!InteractiveImport!~--- тип данных, описывающий подключение модуля (см. листинг \ref{mkmod}). Предусмотрим ситуацию конфликта имён функций, то есть когда в разных модулях имеются определения функций с одинаковыми именами. Добавим для этого возможность не импортировать определённые функции из модуля, если они не потребуются. Итак, если строка-параметр состоит только из имени модуля, тогда создаём простой импорт модуля (соответствует объявлению \lstinline!import ModuleName!) с помощью функции \lstinline!simpleImportDecl!. В противном случае создаём объявление импорта модуля вида \lstinline!import ModuleName hiding (name1, name2, ...)!, то есть в котором указано, объекты с какими именами импортировать не нужно (это могут быть функции, типы данных, классы типов и т. д.).
		
		Непосредственно созданием контекста занимается функция \lstinline!createContext! (см. листинг \ref{crcont}). Эта функция принимает список строк (имена стандартных модулей) и возвращает монаду Ghc (см. гл. \ref{ghcapisec}). Здесь мы устанавливаем флаги для текущей сессии компиляции:
		\begin{enumerate}[1)]
			\item \lstinline!hscTarget!~--- тип кода, который будет являться результатом компиляции, в нашем случае это байткод;
			\item \lstinline!ghcLink!~--- что требуется сделать на этапе компоновки; здесь будем использовать компоновщик, отправляющий код сразу в память, без записи на диск.
		\end{enumerate}
	
		Затем мы подключаем стандартные модули и помещаем все имена из них в созданный контекст с помощью функции \lstinline!getnamesInScope!. Базовый GHC-контекст создан.
		
		\begin{ListingEnv}[h]
		\begin{lstlisting}
mkModuleImport :: String -> InteractiveImport
mkModuleImport mod_info = 
	let info = splitOn " " mod_info
 	in case (length info) of
		1 -> IIDecl $ simpleImportDecl 
			    $ mkModuleName mod_info
		_ -> let simple_import = simpleImportDecl 
			    $ mkModuleName (head info)
			 string_names  = tail info
                         names         = map (noLoc . IEVar . noLoc . mkRdrUnqual .mkVarOcc) string_names
                     in IIDecl 
              $ ImportDecl { 
              ideclSourceSrc = ideclSourceSrc simple_import
            , ideclName      = ideclName simple_import
	    , ideclPkgQual   = ideclPkgQual simple_import
	    , ideclSource    = ideclSource simple_import
	    , ideclSafe      = ideclSafe simple_import
	    , ideclQualified = ideclQualified simple_import
	    , ideclImplicit  = ideclImplicit simple_import
	    , ideclAs        = ideclAs simple_import
	    , ideclHiding    = Just (False, noLoc names) 
	  }
		\end{lstlisting}
		\caption{Реализация функции mkModuleImport} \label{mkmod}
		\end{ListingEnv}
	
		\begin{ListingEnv}[h]
		\begin{lstlisting}
createContext :: [String] -> Ghc [Name]
createContext stmods = do
		dflags <- getSessionDynFlags
		setSessionDynFlags 
			$ dflags { hscTarget = HscInterpreted
			         , ghcLink   = LinkInMemory }
		setContext (map mkModuleImport stmods)
		getNamesInScope
		\end{lstlisting}
		\caption{Реализация функции createContext} \label{crcont}
		\end{ListingEnv}
		
	\subsection{Генерация кода}
		\subsubsection{Определения новых типов данных}
		Нам понадобится промежуточное представление для синтаксического дерева программы. Именно в таком виде сторона Haskell будет получать данные для кодогенерации со стороны C++. Определим тип данных \textit{Expression} (см. листинг \ref{expdata}). У этого типа данных несколько конструкторов:
		\begin{enumerate}[1)]
			\item \lstinline!Param!, описывает параметр функции в её теле;
			\item \lstinline!Literal!, описывает числовой, символьный или логический литералы;
			\item \lstinline!Call!, описывает применение функции (стандартной или определённой пользователем), сюда также относятся конструкторы списка и кортежа, а также условный оператор;
			\item \lstinline!PartApply!, описывает частичное применение функции (стандартной или определённой пользователем), условного оператора, а также конструктора списка и кортежа.			
		\end{enumerate}
		Одним из параметров конструктора \lstinline!Call! имеет тип данных \lstinline!CallInfo!. Это специальный тип данных, который описывает информацию о функции: является ли она стандартной, пользовательской, либо же это унарная или бинарная операция (см. замечание~\ref{rem_un_bin}). 
		
		Введём также вспомогательные типы данных: \textit{BinaryOp} для бинарных операций, \textit{UnaryOp} для унарных операций, \textit{HsType} для встроенных типов данных.

\myremark{
	 Для удобства кодогенерации бинарные и унарные операции выделены отдельно от других стандартных функций. К унарным операциям относятся унарный <<$-$>>, логическое <<не>>, взятие модуля числа, взятие знака числа. К бинарным операциям относятся арифметические операции операции (<<$+$>>, бинарный <<$-$>>, <<$*$>>, <<$/$>>, целочисленное деление, взятие остатка от деления, нахождение наибольшего общего делителя), операции сравнения, логические операции (логическое <<и>>, <<или>>, <<взаимоисключающее или>>). Кроме того, сюда же отнесём функцию <<++>> (конкатенация списков).
}\label{rem_un_bin}

		Кроме того, нам понадобится специальный тип данных \lstinline!FunctionDef! для описания пользовательских функций (см. листинг~\ref{fundata}). Параметрами этого типа данных являются: имя функции, список аргументов функции (может быть пустым), тип её результата, тело функции, а также список вложенных функций (можеть быть пустым). Вложению функций соответствует конструкция \lstinline!where! языка Haskell.
		
		Наконец, определим тип данных \lstinline!FunctionArg! (см. листинг~\ref{funargdata}), описывающий аргумент функции. Его параметрами являются имя аргумента и его тип. 
		
		\begin{ListingEnv}[h]
		\begin{lstlisting}[language=Haskell]
data Expression = Param String
	        | Literal HsType String
                | Call CallInfo HsType [Expression]
                | PartApply [Expression] Expression
                | Empty
deriving (Read, Show, Eq)	
	
data CallInfo = BuiltIn String | Custom String | Binary BinaryOp | Unary UnaryOp
deriving (Read, Show, Eq)
		\end{lstlisting}
		\caption{Определение типа данных Expression}\label{expdata}
		\end{ListingEnv}
	
	\begin{ListingEnv}[h]
	\begin{lstlisting}[language=Haskell]
data FunctionDef = FunctionDef { 
	  fun_name    :: String
	, args        :: [ FunctionArg ]
	, result      :: HsType 
	, body        :: Expression
	, nested_funs :: [FunctionDef] 
} 
deriving (Show, Read)
	\end{lstlisting}
	\caption{Определение типа данных FunctionDef}\label{fundata}
	\end{ListingEnv}

\begin{ListingEnv}[h]
\begin{lstlisting}[language=Haskell]
data FunctionArg = FunctionArg { 
	arg_name :: String
      , arg_type :: HsType 
 }
deriving (Show, Read)
\end{lstlisting}
\caption{Определение типа данных FunctionArg}\label{funargdata}
\end{ListingEnv}
		
		\subsubsection{Непосредственно кодогенерация}
		Теперь, когда все необходимые для работы типы данных у нас имеются, можно приступать к кодогенерации. Функция, которую мы сперва здесь определим~--- это функция \lstinline!generate_exp :: Expression -> Exp!. Как видно из её прототипа, эта функция принимает выражения типа \lstinline!Expression!, а возвращает выражение типа данных \lstinline!Exp! (см. гл.~\ref{temphassec}) (см. листинг~\ref{genexp}). С помощью \textit{паттерн-матчинга} по конструкторам типа данных \lstinline!Expression! осуществим выбор нужной функции.

\begin{ListingEnv}[h]
\begin{lstlisting}[language=Haskell]
generate_exp :: Expression -> Exp
generate_exp (Param a)     = generate_param (Param a)
generate_exp (Literal a b) = generate_liter (Literal a b)

generate_exp (PartApply xs exp) = generate_partapply xs exp
generate_exp (Call info t xs)   = generate_call info t xs
\end{lstlisting}
	\caption{Определение функции generate\_exp}\label{genexp}
\end{ListingEnv}

	\subsection{Компиляция кода}
	\subsection{Взаимодействие между кодами на языках C++ и Haskell}
	\subsection{Обработка исключений}
\section{Пример работы кодогенератора}
Для демонстрации работы кодогенератора поступим следующим образом. Изобразим в IDE визуального языка программу. Для неё вручную напишем соответствующий ей код на языке Haskell, чтобы затем сравнить его с кодом, который даст кодогенератор. После скомпилируем и выполним обе программы и сравним результаты.

Изобразим программу вычисления длины целочисленного списка рекурсивным образом (см. рис. \ref{lengthrec}). Затем напишем код, который соответствует изображённому нами синтаксическому дереву (см. табл. \ref{expectreal}, левая колонка). 

Теперь получим промежуточное представление синтаксического дерева (см. листинг \ref{intermed}). Из промежуточного представления видно, что имеется две функции: основная функция, вычисляющая длину конкретного списка с помощью функции, определённой пользователем, и собственно функция вычисления длины списка, определённая пользователем. Основная функция не имеет аргументов и вложенных функций. Функция вычисления длины целочисленного списка имеет один аргумент (собственно список) и также не имеет вложенных функций. Это полностью отвечает тому, что мы изобразили в IDE.

Получаем код, который создаёт кодогенератор (см. табл. \ref{expectreal}, правая колонка). Видно, что он абсолютно идентичен коду, который был написан вручную: различаются только имена функций и их аргументов, порядок функций в программе.

Наконец, исполним функции с названием \lstinline!root! из обеих колонок табл. \ref{expectreal} и сравним результаты их вычислений. Результаты вычислений представлены в таблице \ref{exprealres}. Вычисление обеих функций дало одинаковый результат.

\begin{figure}[p]
\centering
\includegraphics[width=\textwidth]{img/length.PNG}
\caption{Реализация функции, вычисляющей длину списка, и её применение} \label{lengthrec}	
\end{figure}

\begin{ListingEnv}[h]
\begin{lstlisting}
FunctionDef {
    fun_name = "root"
  , args = []
  , result = HsInt
  , body = Call (Custom "function1") (HsInt) 
          [Call (BuiltIn "list") (HsList (HsInt)) 
          [Literal HsInt "0"
         , Literal HsInt "1"
         , Literal HsInt "2"
         , Literal HsInt "3"
         , Literal HsInt "4"
         , Literal HsInt "5"
         , Literal HsInt "6"]]
  , nested_funs = []
 }
 
FunctionDef {
    fun_name = "function1"
  , args = [FunctionArg {
              arg_name = "function1_arg0"
            , arg_type = HsList (HsInt)}]
  , result = HsInt
  , body = Call (BuiltIn "if") (HsInt) 
          [Call (BuiltIn "null") (HsBool) 
          [Param "function1_arg0"]
        , Literal HsInt "0"
        , Call (Binary Add) (HsInt) 
          [Call (Custom "function1") (HsInt) 
          [Call (BuiltIn "tail") (HsList (HsInt)) 
          [Param "function1_arg0"]]
        , Literal HsInt "1"]]
  , nested_funs = []
 }
\end{lstlisting}
\caption{Промежуточное представление программы}\label{intermed}
\end{ListingEnv}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|}
\hline
Код, написанный программистом &
Сгенерированный код \\
\hline
\begin{lstlisting}
length_rec :: [Int] -> Int
length_rec xs = 
 if null xs
  then 0
  else length_rec (tail xs) + 1

root :: Int
root = 
 length_rec [0, 1, 2, 3, 4, 5, 6]
\end{lstlisting} &
\begin{lstlisting}
root :: Int
root = 
 function1 [0, 1, 2, 3, 4, 5, 6]

function1 :: [Int] -> Int
function1 function1_arg0 = 
 if null function1_arg0
  then 0
  else 
   function1 (tail function1_arg0)
     + 1
\end{lstlisting} \\
\hline
\end{tabular}
\caption{Сравнение ожидаемого и сгенерированного кода}\label{expectreal}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|}
\hline
Ожидаемые результаты & Полученные результаты \\
\hline
 & \\
\begin{minipage}{2in}
	\begin{verbatim}
*Main> root
7
	\end{verbatim}
\end{minipage} &
~~~~~~~\includegraphics{img/result.PNG} \\
 & \\
\hline
\end{tabular}
\caption{Сравнение результатов вычислений ожидаемой и сгенерированной функции}\label{exprealres}
\end{table}

\chapter{Тестирование}
\section{Тест <<Переприсоединение>>}
Тест <<Переприсоединение>> (англ. \textit{test-reconnect}) был задуман с целью автоматизации проверки того, что состояние контекста каждого компонента остаётся прежним после удаления и восстановления одной из входящих связей.
\section{Тест <<Все ко всем>>}
Тест <<Все ко всем>> (англ. \textit{all-to-all test}) воспроизводит попытки создания всевозможных явных связей (включая некорректные) для каждого конкретного примера. Это необходимо для проверки того, что все ошибочные ситуации обрабатываются правильно. К ошибочным ситуациям относятся:
\begin{itemize}
	\item попытка создания связи, которая приводит к циклу в синтаксическом дереве;
	\item попытка создания связи, которая приводит к появлению бесконечного типа;
\end{itemize}

\Conc

% Печать списка литературы (библиографии)
\nocite{*}
\printbibliography[%{}
    heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

%\appendix
%\ifthenelse{\value{worktype} > 1}{%
  %\addtocontents{toc}{%
      %\protect\renewcommand{\protect\cftchappresnum}{\appendixname\space}%
      %\protect\addtolength{\protect\cftchapnumwidth}{\widthof{\appendixname\space{}} - \widthof{Глава }}%
  %}%
%}{
  %\addtocontents{toc}{%
      %\protect\renewcommand{\protect\cftsecpresnum}{\appendixname\space}%
      %\protect\addtolength{\protect\cftsecnumwidth}{\widthof{\appendixname\space{}}}%
  %}%
%}

%\section{Пример работы программы}

%Здесь длинный листинг с примером работы.

\end{document}
