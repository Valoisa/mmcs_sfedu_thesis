% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (section) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}
\hyphenation{Monad Applicative Functor Control Data}
    \tikzstyle{every node}=[shape=rectangle, color=black, rounded corners,%
    text=black, anchor=west]
    \tikzstyle{selected}=[shape=rectangle, rounded corners,%
    top color=gray,%
    bottom color=gray, text=white]
    \tikzstyle{optional}=[dashed,fill=gray!50]

\begin{document}

\Intro
\section*{Цель работы}
\section*{Постановка задачи}

\chapter{Предварительные сведения}

\chapter{Алгоритм выведения типов}
\section{Основные понятия}
Для начала введём основные термины, которые будут использоваться при описании алгоритма выведения типов.
\begin{description}
	\item[Компонент.] Компонентами являются встроенные функции. <Добавить также изображение компонента>
	\item[Функция.] Если не указано иное, функцией будем называть определённую пользователем функцию.
	\item[Вызывающий компонент (caller).] Компонент, предназначающийся для использования определённой пользователем функции.
	\item[Связь (connection).]
	\item[Вход (connection point).] Вход компонента соответствует одному аргументу функции. На вход можно подать значение (одно из возможных значений типа, который назначен данному входу) либо другой компонент. Компонент может не иметь входов, если это: 
	\begin{enumerate}[1)]
		\item аргумент определяемой пользователем функции;
		\item вызывающий компонент (caller) пользовательской функции без аргументов.
	\end{enumerate} 
	\item[Контекст.] description
	\item[Инферер (inferer).] description
	\item[Алиас (alias).] description
\end{description}
 
\chapter{Проблемы и их решения}

\chapter{Детали реализации}

\chapter{Кодогенерация}
\section{Постановка задачи кодогенерации}
Для программы на визуальном языке сгенерировать соответствующий ей код на языке Haskell. Полученный код должен компилироваться с помощью GHC. Затем корневая функция должна вычислиться, а её результат~--- передаться в основную программу.
\section{План решения}
Решение поставленной задачи состоит из следующих шагов.
\begin{enumerate}[1.]
	\item На стороне Haskell:
		\begin{enumerate}[1)]
			\item создавать GHC-контекст, в который помещать определения функций из стандартных модулей (включая базовый модуль Prelude);
			\item генерировать код на основе данных, полученных из основной программы;
			\item компилировать полученный код и помещать в созданный на шаге 1.1 контекст новые определения;
			\item вызывать требуемую функцию и её результат передавать в основную программу;
			\item если выполнение или компиляция завершились с ошибкой, т.е. произошёл выброс исключения, сообщить об этом основной программе.
		\end{enumerate}
	\item На стороне C++:
		\begin{enumerate}[1)]
			\item передать стороне Haskell данные для генерации кода;
			\item получить результат вычисления требуемой функции.
		\end{enumerate}
\end{enumerate}
\section{Программные средства}
Для решения данной задачи было решено использовать следующие средства языка Haskell.

	\subsection{Template Haskell (TH)} Template Haskell~--- стандартный фреймворк, предоставляющий средства для типобезопасного метапрограммирования на языке Haskell, обрабатываемые на этапе компиляции компилятором GHC. [ссылка на хаскель вики]  TH позволяет писать мета-программы на языке Haskell, результатом выполнения которых являются другие программы на языке Haskell. Данный фреймворк применяется для кодогенерации во времени выполнения а также для создания доменно-специфичных языков. Для решения нашей задачи нам потребуется возможность сгенерировать синтаксическое дерево (представляемое специальными типами данных) и получить его строковое представление (т.е. в виде программного кода на языке Haskell) с помощью функций структурной печати (англ. \textit{pretty-printing}).
	
	\subsubsection{Основные используемые типы данных} Для кодогенерации нам понадобятся следующие типы данных: \lstinline!data Exp! и \
	\lstinline!data Dec!. Первый из них представляет собой тип данных, отвечающим \textit{выражению} на языке Haskell, т.е. этим типом данных описываются переменные, литералы, применения функций, условные выражения и т.д. (см. табл. \ref{expconstr}). Второй описывает \textit{определения} на языке Haskell, например, функции, определения новых типов данных, классов типов, синонимов типов и др. (см. табл. \ref{decconstr}).
	
	\subsubsection{Возможные проблемы} Среди программистов на языке Haskell использование TH считается небезопасным [ссылка на ugly but necessary]. Этому есть причины. Например, с помощью TH можно сгенерировать такой код, который не будет компилироваться (не пройдёт проверку типов) [ссылка на what's so bad about TH]. Тем не менее, мы будем предполагать, что алгоритм выведения типов нашего визуального языка работает корректно, а потому сгенерированный таким образом код будет рабочим.
	
\begin{table}[h]
	\begin{center}
		\begin{tabular}{ll}
			{\lstinline!VarE Name!} & имя переменной \\
			{\lstinline!ConE Name!} & имя конструктора типа данных \\
			{\lstinline!LitE Lit!} & литерал (числовой или символьный) \\
			{\lstinline!AppE Exp Exp!} & применение функции \\
			{\lstinline!InfixE (Maybe Exp) Exp (Maybe Exp)!} & бинарная операция, возможно, \\ & частично применённая \\
			{\lstinline!LamE [Pat] Exp!} & лямбда-выражение \\
			{\lstinline!TupE [Exp]!} & кортеж \\
			{\lstinline!CondE Exp Exp Exp!} & условное выражение \\
			{\lstinline!ListE [Exp]!} & список \\
		\end{tabular}
	\end{center}
\caption{Некоторые конструкторы типа данных Exp}
\label{expconstr}
\end{table}

\begin{table}[h]
\begin{center}
	\begin{tabular}{ll}
		{\lstinline!FunD Name [Clause]!} & определение функции \\
										 & {\lstinline!func x y = ...!} \\
		{\lstinline!SigD Name Type!} & прототип (сигнатура) функции \\
									 & {\lstinline!func :: a -> a -> a!}
	\end{tabular}
\end{center}
\caption{Некоторые конструкторы типа данных Dec}
\label{decconstr}
\end{table}
	% Библиотека для метапрограммирования на языке Haskell. Предоставляет возможность генерировать код на языке Haskell с помощью специальных типов данных, затем возвращать его строковое представление с помощью функций структурной печати (\textit{pretty-printing}). Не гарантирует, что сгенерированный таким образом код пройдёт проверку системы типов. Однако будем предполагать, что такую гарантию нам даёт наш собственный алгоритм выведения типов.
	\subsection{GHC API~--- программный интерфейс компилятора} Функционал GHC может быть использован не только для компиляции программ на языке Haskell. Важным примером использования может послужить анализ и, возможно, преобразование кода на языке Haskell. Другим примером является динамическая загрузка кода, как	в GHCi [4]. Для этих целей функционал GHC доступен через библиотеку GHC API.
	
	Рассмотрим некоторые модули этой библиотеки, функционал которых применялся в данной работе.
	\begin{description}
		\item[InteractiveEval.] Предоставляет функции для манипуляции выражениями языка Haskell, в том числе и для их исполнения. Работа с выражениями происходит в специально создающемся для этого контексте интерактивных вычислений (англ. interactive evaluation context). Этот контекст содержит все определения, которые в него были помещены. В него можно импортировать и определения стандартных модулей.
		\item[DynFlags.] В этом модуле описаны параметры компиляции. Большинство флагов являются динамическими. Это означает, что они могут изменяться от одного процесса компиляции к другому.
		\item[HsImpExp.] Здесь содержатся типы данных и функции, предназначенные для работы с импортом модулей. Модуль в языке Haskell можно подключить различными способами: стандартным образом (т.е. использовать все определения из него), импортируя только конкретные функции, запрещая импортировать некоторые функции и так далее. Функционал модуля HsImpExp позволяет это сделать, например, для интерактивного контекста.
		\item[GHC.] Модуль, посвящённый работе с монадой GHC. Это монада, содержащая весь функционал, необходимый для вызовов функций GHC API. 
	\end{description} 

	Более подробно см. документацию по GHC API [ссылка]. % API компилятора GHC. Для решения поставленной задачи мы воспользуемся такими возможностями этой библиотеки, как создание контекста и привнесение в него определений (которые мы будем генерировать с помощью Template Haskell), а также исполнение функций интерпретатором. 
	\subsection{Foreign Function Interface (FFI)} Это расширение стандарта языка Haskell. Оно позволяет программам на языке Haskell взаимодействовать с программами, написанными на других языках. Таким образом, с помощью этого расширения программы на языке Haskell могут вызывать программы, написанные на других языках, и наоборот: программы на различных языках получают возможность вызывать программы на языке Haskell. В нашем случае мы будем использовать средства взаимодействия с языком C. 
	
	\subsubsection{Соглашение о вызове} Для того, чтобы взаимодействовать с кодом, написанным на другом языке, необходимо знать \textit{соглашение о вызове} (англ. \textit{calling convention}), использующееся реализацией другого языка в текущей архитектуре. С помощью FFI компилятор языка Haskell GHC поддерживает стандартные соглашения о вызове, такие как \lstinline{cdecl}, \lstinline{pascal} и другие. Например, пусть при объявлении функции, предназначенной для другого языка программирования, указано соглашение о вызове \lstinline{cdecl}. Тогда GHC сгенерирует такой код, при исполнении которого параметры будут расположены в памяти и в регистрах таким образом, как того ожидает компилятор языка C (или любой другой компилятор, использующий то же соглашение о вызове). А именно, аргументы функций передаются справа налево; очистку стека производит вызывающая программа.
	
	Соглашение о вызове зависит от типов параметров. Только некоторые типы данных языка Haskell могут быть напрямую использованы для функций, предназначенных для других языков, потому что эти типы данных отвечают базовым типам данных низкоуровневых языков программирования. Рассмотрим некоторые типы данных, которые будут нами позднее использованы.
	
	\subsubsection{Основные используемые типы данных} Значение типа \lstinline{Ptr a} представляет собой указатель на объект или массив объектов, который может быть маршалирован (англ. \textit{marshalled}) в значения языка Haskell типа \lstinline{a} (или наоборот, из массива значений языка Haskell в массив значений другого языка). Тип данных \lstinline{a}, как правило, является экземпляром класса \lstinline{Storable}, который предоставляет операции маршалинга (англ. \textit{marshalling}). Однако это не существенно: пользователь может реализовать собственные операции доступа к указателю.
	
	Также нам понадобится тип данных \lstinline{CWString}. Он является синонимом типа данных \lstinline{Ptr CWchar} и представляет собой указатель на массив символов в кодировке Unicode в языке C, завершающийся пустым символом (т.е. \lstinline{wchar_t*} в языке C).
	
	\textit{Устойчивый указатель} (англ. \textit{stable pointer})~--- это ссылка на выражение языка Haskell, значение которого сборщиком мусора гарантировано не будет ни удалено (т.~е. память, выделенная под него, не будет освобождена), ни перемещено в другую область памяти. Таким образом, устойчивые указатели могут быть переданы в код на другом языке программирования, который будет обращаться с ними как с ссылками на значения языка Haskell, закреплённые в памяти (аналогом такой конструкции можно считать закреплённый указатель (англ. \textit{pinned pointer}) в языке C\#). Таким образом, мы сможем создать контекст, представленный монадой \textit{Ghc}, создать устойчивый указатель на него, а затем использовать его в языке C. Со стороны языка C мы будем манипулировать им как указателем типа~\lstinline{void*}.   % Библиотека языка Haskell, которая позволяет создавать функции на языке Haskell, предназначенные для исполнения их на другом языке программирования (в данном случае C/C++). Позволяет работать с некоторыми типами данных языков C/C++, в том числе позволяет создавать указатели, что нам пригодится для работы с контекстом.

\section{Решение и детали реализации решения}
	\subsection{Создание GHC-контекста}
		Для начала создадим GHC-контекст, куда поместим определения из стандартных модулей. Для этого определим функцию \lstinline!mkModuleImport!, которая принимает строку, а возвращает \lstinline!InteractiveImport!~--- тип данных, описывающий подключение модуля [ссылка на листинг]. Предусмотрим ситуацию конфликта имён функций, то есть в разных модулях имеются определения функций с одинаковыми именами. Добавим для этого возможность не импортировать определённые функции из модуля, если они не потребуются.
	\subsection{Генерация кода}
		\subsubsection{Определение типа данных Expression}
		\subsubsection{Непосредственно кодогенерация}
	\subsection{Взаимодействие между кодами на языках C++ и Haskell}
\section{Результаты работы кодогенератора}

\chapter{Тестирование}
\section{Тест <<Переприсоединение>>}
Тест <<Переприсоединение>> (англ. \textit{test-reconnect}) был задумал с целью автоматизации проверки того, что состояние инферера каждого компонента остаётся прежним после удаления и восстановления одной из входящих связей.
\section{Тест <<Все ко всем>>}
Тест <<Все ко всем>> (англ. \textit{all-to-all test}) воспроизводит попытки создания всевозможных связей для каждого конкретного примера. Это необходимо для проверки того, что все ошибочные ситуации обрабатываются правильно. К ошибочным ситуациям относятся:
\begin{itemize}
	\item попытка создания связи, которая приводит к циклу в синтаксическом дереве;
	\item попытка создания связи, которая приводит к появлению бесконечного типа;
\end{itemize}


% Печать списка литературы (библиографии)
\printbibliography[%{}
    heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

%\appendix
%\ifthenelse{\value{worktype} > 1}{%
  %\addtocontents{toc}{%
      %\protect\renewcommand{\protect\cftchappresnum}{\appendixname\space}%
      %\protect\addtolength{\protect\cftchapnumwidth}{\widthof{\appendixname\space{}} - \widthof{Глава }}%
  %}%
%}{
  %\addtocontents{toc}{%
      %\protect\renewcommand{\protect\cftsecpresnum}{\appendixname\space}%
      %\protect\addtolength{\protect\cftsecnumwidth}{\widthof{\appendixname\space{}}}%
  %}%
%}

%\section{Пример работы программы}

%Здесь длинный листинг с примером работы.

\end{document}
