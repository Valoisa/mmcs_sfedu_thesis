% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}
\hyphenation{Monad Applicative Functor}


\begin{document}

\Intro

Функциональные языки имеют множество неоспоримых достоинств, таких как: повышенная надёжность кода, удобство организации модульного тестирования, возможности оптимизации при компиляции, возможности автоматического распараллеливания вычислений. Поэтому в последнее время языки функционального программирования стремительно развиваются. Одним из наиболее популярных функциональных языков является \textit{Haskell} ~---  язык программирования общего назначения, имеющий полную, сильную, статическую систему типов.

\subsection*{Цель работы}
Одной из идиом языка программирования \textit{Haskell} являются так называемые \textit{классы типов}. Классы типов в некотором смысле схожи с интерфейсами  объектно-ориентированных языках. В частности, классы типов также реализуют наследование, при котором наследник уточняет функционал предка. Однако класс \textit{Monad}, по смыслу наследовавший класс \textit{Applicative}, синтаксически оставался самостоятельным классом.

В марте 2015 года вышла новая версия компилятора: GHC 7.10. В этой версии было реализовано предложение, известное как \textit{The Applicative Monad Proposal}.[link to AMP] Суть этого предложения заключается в том, чтобы сделать класс \textit{Monad} подклассом класса \textit{Applicative}, в результате чего получается следующая цепочка: \textit{Functor --- Applicative --- Monad}. Теперь, описывая экземпляры класса \textit{Monad}, необходимо также создавать экземпляры классов \textit{Functor} и \textit{Applicative}. В версия GHC, младших, чем 7.10 \textit{Monad} был самостоятельным классом, поэтому для получения работоспособного кода в этих экземплярах не было необходимости. Таким образом, в результате этих изменений, часть программ, компилирующихся версиями GHC, младше, чем 7.10, перестали компилироваться версией GHC 7.10.

\subsection*{Постановка задачи}
Дописывать необходимые экземпляры вручную непрактично, особенно в случае больших объёмов кода. Поэтому требуется создать программное средство, которое восстановит компилируемость этих программ.

Было принято решение создать утилиту с помощью средств самого языка Haskell, а именно при помощи библиотеки \textit{GHC API} --- программного интерфейса компилятора GHC. Утилита должна работать следующим образом:
\begin{enumerate}[1)]
\item получать синтаксическое дерево программы;
\item отфильтровывать узлы, соответствующие экземплярам класса \textit{Monad};
\item изменять нужным образом экземпляр класса \textit{Monad} и добавлять, если требуется, экземпляры классов \textit{Applicative} и \textit{Functor}.
\item формировать новый файл с текстом программы с помощью функций структурной печати (\textit{pretty-printing}).
\end{enumerate}


% Если typeOfWork в SETUP.tex задан как 2 или 3, то начинать
% надо не с section (раздел), а с главы (chapter)
\section{Предварительные сведения}
\label{sec:prelim}

\subsection{GHC: создание, развитие, архитектура}
\textbf{Glasgow Haskell Compiler (GHC)} ~--- один из наиболее развитых на сегодняшний день компилятор языка Haskell. Является кроссплатформенным компилятором с открытым исходным кодом. На данный момент история развития GHC насчитывает более двадцати лет. С моента своего создания компилятор постоянно совершенствуется. Сначала GHC был частью академического исследовательского проекта, который спонсировался правительством Великобритании в начале 1990-х годов. Создатели GHC преследовали несколько целей:
\begin{itemize}
\item создать широкодоступный, надёжный компилятор языка \textit{Haskell}, генерирующий высокопроизводительный код;
\item обеспечить модульную основу, которую другие исследователи могли бы развивать и расширять;
\item изучать работу программ, чтобы улучшить дальнейшую разработку компиляторов.
\end{itemize}

GHC можно разделить на три сущности:
\begin{description}
\item[Собственно компилятор.] По существу представляет собой программу на языке \textit{Haskell}, которая преобразует исходный код в исполняемый машинный код.
\item[Загрузочные библиотеки (Boot Libraries).] GHC создан методом \textit{раскрутки компилятора} (англ. \textit{bootstrapping})[link to wiki], т.~е. GHC написан на самом языке Haskell. GHC комплектуется набором библиотек, называемых \textit{загрузочными}, поскольку на них базируется сам компилятор. Наличие этих библиотек позволяет GHC осуществить раскрутку.
\item[Среда выполнения (The Runtime System, RTS).] Написана на языках \textit{C} и \textit{C$--$}. Обрабатывает все задачи, связанные с запуском скомпилированного кода на языке \textit{Haskell}.
\end{description}
На самом деле, такое разделение в точности соответствует трём подкаталогам дерева исходных кодов GHC: \textit{compiler}, \textit{libraries} и \textit{rts} соответственно.

Остановимся подробнее на самом \textbf{компиляторе}.

Компилятор, в свою очередь, также можно разделить на несколько частей.
\begin{description}
\item[Диспетчер компиляции (compilation manager).] Отвечает за компиляцию исходного кода, состоящего из нескольких и более модулей. Его задача заключается в том,чтобы определять, в каком порядке следует компилировать модули, а также какие модули перекомпилировать не нужно, если с момента последней компиляции в их зависимости не были внесены изменения.
\item[Компилятор языка Haskell (Haskell compiler, Hsc).] Управляет компиляцией одного файла исходного кода. Большинство действий над кодом совершается именно здесь.
\item[Конвейер (pipeline).] Отвечает за коллаборацию \textit{Hsc} с необходимыми внешними программами. Например, иногда файл исходного кода сначала должен пройти предварительную обработку через препроцессор $C$ прежде чем быть переданным Hsc. Выходной же файл Hsc ~--- это обычно файл на языке ассемблера, который должен затем быть переданным ассемблеру для получения объектного файла.
\end{description}

%Внешний интерфейс (front end) GHC (включающий лексический анализатор (lexer), синтаксический анализатор (parser) и верификатор типов (typechecker)) устроен таким образом, чтобы (<слишком сложно, не могу перевести, да и надо ли об этом говорить... Но если не об этом, то о чём тогда?!>)


\subsection{GHC 7.8 ~--- GHC 7.10}
Как уже было сказано, GHC ~--- один из наиболее развитых компиляторов языка \textit{Haskell} на сегодняшний день. Обновления для GHC выходят регулярно. К сожалению, иногда выход обновлений приводит к определённым проблемам, как, например, потеря обратной совместимости. В данной работе решается проблема обратной совместимости версий GHC 7.10 и версий, младше 7.10.

Так, одним из изменений, появившихся в GHC 7.10, отличающих его от GHC 7.8 стала реализация предложения, известного как \textit{Applicative Monad Proposal} (\textit{AMP}). Суть его состоит в том, чтобы сделать класс \textit{Applicative} надклассом класса \textit{Monad} (и в дополнение к классу \textit{MonadPlus}). [link to AMP] 

Так, в версиях GHC младших, чем 7.10 \textit{Monad} был самостоятельным классом. Однако по смыслу он уточнял функционал класса \textit{Applicative}. Так, идентичными являются функции:
\begin{itemize}
\item \textbf{pure} из \textit{Applicative} и \textbf{return} из \textit{Monad}: обе принимают <<чистое>> значение и помещают его в минимальный контекст по умолчанию;
\item \textbf{$>*$} из \textit{Applicative} \textbf{$>>$} из \textit{Monad} работают идентично.
\end{itemize}
Однако \textit{Monad} <<уточнял>> функционал \textit{Applicative} с помощью функции \textbf{$>>=$} (\textit{связывание, bind}). Таким образом, было принято решение сделать класс \textit{Monad} подклассом класса \textit{Applicative} также и синтаксически.

О других изменениях, произошедших в GHC 7.10 по сравнению с GHC 7.8 см \textit{Release notes for version 7.10.1}[link]

%\begin{figure}[h]
%\begin{lstlisting}
%\end{lstlisting}
%\caption{Реализация класа Monad в GHC 7.8 (библиотека base версии 4.7.0.2).}\label{oldmonad}
%\end{figure}

\subsection{GHC API ~--- программный интерфейс компилятора}
Функционал GHC может быть использован не только для компиляции программ на языке Haskell. Важным примером использования может послужить анализ и, возможно, преобразование кода на языке Haskell. Другим примером является динамическая загрузка кода, как в GHCi.[link to GHC as a Library] Для этих целей функционал GHC доступен через библиотеку GHC API.

Рассмотрим основные модули этой библиотеки, функционал которых применялся в данной работе.
\begin{description}
\item[Parser.] Данный модуль предоставляет функции, которые проводят лексический анализ (\textit{parsing}) кода на языке \textit{Haskell}. Данные функции принимают файл или строку исходного кода и дают на выходе абстрактное синтаксическое дерево (\textit{abstract syntax tree}, \textit{AST}), либо сообщение об ошибке.
\item[HsSyn.] Содержит описание структуры верхнего уровня для модуля (\textit{HsModule}). Объект такого типа данных можно получить, если к файлу с исходным кодом применить функцию \textbf{parseModule} из модуля \textit{Parser}.
\item[HsDecls.] Здесь определён абстрактный синтаксис для глобальных объявлений, таких как объявление типа, класса, экземпляра и т.~д.
\item[HsTypes.] В данном модуле описан абстрактный синтаксис для типов, определённых пользователем.
\item[Outputable.] В данном модуле определены классы и функции структурной печати (\textit{pretty-printing}). В частности, здесь определён класс \textbf{Outputable}: если тип данных имеет экземпляр этого класса, значит, к нему можно применять функции структурной печати. Эти функции возвращают объект типа данных \textbf{SDoc}, который в свою очередь легко преобразовать к строке.
\item[DynFlags.] Параметры компиляции. Большинство флагов являются динамическими. Это означает, что они могут изменяться от одного процесса компиляции к другому.
\item[SrcLoc.] Данный модуль содержит типы, относящиеся к положению различных элементов в файле исходного кода и позволяющие присваивать метки этом положениям. 
\end{description}

Более подробно см. документацию по GHC API [link to GHC API]

\newpage
\section{Решение}
\subsection{Получить синтаксическое дерево}
\subsection{Отфильтровать экземпляры класса Monad}
\subsection{Генерация экземпляров классов Applicative и Functor}
\subsection{Формирование выходного файла}
\subsection{Другие способы решения}


% Печать списка литературы (библиографии)
\printbibliography[%{}
    heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
